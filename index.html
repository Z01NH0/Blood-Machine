
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLOOD MACHINE: INFERNO CYCLES</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Rajdhani', 'Courier New', monospace;
        }

        body {
            background-color: #000;
            overflow: hidden;
            color: #fff;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        #titleContainer {
            text-align: center;
            margin-bottom: 60px;
            animation: titleGlow 2s infinite alternate;
        }

        @keyframes titleGlow {
            0% { filter: drop-shadow(0 0 10px #ff0000); }
            100% { filter: drop-shadow(0 0 20px #ff3333); }
        }

        #gameTitle {
            font-size: 82px;
            color: #ff0000;
            font-weight: bold;
            letter-spacing: 5px;
            margin-bottom: 10px;
        }

        #gameSubtitle {
            font-size: 28px;
            color: #ff9900;
            letter-spacing: 3px;
        }

        .menuButtons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 40px;
        }

        .menuButton {
            padding: 20px 60px;
            font-size: 32px;
            background: linear-gradient(45deg, #222, #444);
            color: #fff;
            border: 3px solid #ff0000;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 300px;
            position: relative;
            overflow: hidden;
        }

        .menuButton:hover {
            background: linear-gradient(45deg, #333, #555);
            transform: scale(1.05);
            box-shadow: 0 0 25px #ff0000;
        }

        .menuButton::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,0,0,0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .menuButton:hover::before {
            transform: rotate(45deg) translate(50%, 50%);
        }

        #instructionsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 400;
            display: none;
            overflow-y: auto;
            padding: 40px;
        }

        #instructionsTitle {
            text-align: center;
            font-size: 48px;
            color: #ff9900;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #ff9900;
        }

        .instructionsContainer {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
        }

        .instructionSection {
            background: rgba(30, 30, 40, 0.8);
            border: 2px solid #ff0000;
            border-radius: 10px;
            padding: 25px;
            transition: transform 0.3s;
        }

        .instructionSection:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(255,0,0,0.3);
        }

        .sectionTitle {
            font-size: 24px;
            color: #00aaff;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #00aaff;
        }

        .controlItem {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .controlKey {
            background: #444;
            padding: 5px 15px;
            border-radius: 5px;
            border: 1px solid #666;
            font-weight: bold;
            color: #fff;
        }

        .controlDescription {
            color: #ccc;
            text-align: right;
            flex: 1;
            margin-left: 20px;
        }

        .weaponInfo {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(50, 50, 50, 0.5);
            border-radius: 5px;
        }

        .weaponIcon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: #000;
        }

        #backButton {
            position: fixed;
            bottom: 40px;
            right: 40px;
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #222, #444);
            color: #fff;
            border: 3px solid #ff0000;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #backButton:hover {
            background: linear-gradient(45deg, #333, #555);
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0000;
        }

        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #resourceContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            min-width: 300px;
        }

        #healthBar {
            width: 280px;
            height: 28px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff0000;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        #healthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff00 0%, #aaff00 50%, #ffff00 100%);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        #healthFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.2) 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                rgba(255, 255, 255, 0.2) 100%);
            animation: healthPulse 2s infinite;
        }

        @keyframes healthPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        #healthText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px #00ff00;
            letter-spacing: 1px;
            font-family: 'Rajdhani', monospace;
        }

        #staminaContainer {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #staminaBars {
            display: flex;
            gap: 4px;
            width: 280px;
        }

        .stamina-segment {
            flex: 1;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00aaff;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            transition: all 0.3s;
        }

        .stamina-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(180deg, #00aaff 0%, #0088ff 100%);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stamina-segment.empty {
            border-color: #ff0000;
            background: linear-gradient(180deg, rgba(255,0,0,0.2) 0%, rgba(200,0,0,0.1) 100%);
        }

        .stamina-segment.empty .stamina-fill {
            width: 0;
        }

        #staminaLabel {
            font-size: 12px;
            color: #00aaff;
            text-shadow: 0 0 5px #00aaff;
            font-family: 'Rajdhani', monospace;
            letter-spacing: 1px;
        }

        #scoreContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            min-width: 200px;
        }

        #scoreDisplay {
            font-size: 22px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #ff9900;
            font-family: 'Rajdhani', monospace;
        }

        #styleRank {
            font-size: 36px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 15px #ff9900;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-family: 'Rajdhani', monospace;
            letter-spacing: 2px;
        }

        #stylePointsContainer {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 6px;
            padding: 8px;
            width: 220px;
            display: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
        }

        .stylePoint {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 12px;
            animation: stylePointFade 2s forwards;
            font-family: 'Rajdhani', monospace;
        }

        @keyframes stylePointFade {
            0% { opacity: 0; transform: translateX(20px); }
            20% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-20px); }
        }

        .stylePointType {
            color: #00ff00;
        }

        .stylePointValue {
            color: #ffff00;
            font-weight: bold;
        }

        #weaponContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            min-width: 250px;
        }

        #weaponInfo {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        #weaponName {
            font-size: 20px;
            color: #fff;
            text-shadow: 0 0 8px #00ffff;
            font-weight: bold;
            letter-spacing: 1px;
            font-family: 'Rajdhani', monospace;
        }

        #weaponCooldown {
            font-size: 14px;
            color: #ffff00;
            text-shadow: 0 0 5px #ff9900;
            font-family: 'Rajdhani', monospace;
        }

        #weaponSpecial {
            font-size: 12px;
            color: #ff9900;
            margin-top: 2px;
            text-shadow: 0 0 5px #ff9900;
            font-family: 'Rajdhani', monospace;
        }

        #styleMeter {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 400px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 3px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        #styleFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                #00aa00 0%, 
                #aaff00 20%, 
                #ffff00 40%, 
                #ff9900 60%, 
                #ff0000 80%, 
                #ff00ff 100%
            );
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        #styleFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                transparent 100%);
            animation: styleScan 2s infinite linear;
        }

        @keyframes styleScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #styleText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
            font-family: 'Rajdhani', monospace;
        }

        #enemyHealthContainer {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            display: none;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            min-width: 350px;
            backdrop-filter: blur(5px);
        }

        #enemyName {
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 8px;
            font-weight: bold;
            font-family: 'Rajdhani', monospace;
            letter-spacing: 2px;
        }

        #enemyHealthBar {
            width: 400px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 1px solid #fff;
            border-radius: 3px;
            overflow: hidden;
        }

        #enemyHealthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff3333, #ff6666);
            transition: width 0.3s;
            position: relative;
        }

        #enemyHealthFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                rgba(255, 255, 255, 0.3) 100%);
            animation: enemyHealthPulse 1.5s infinite;
        }

        @keyframes enemyHealthPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 20;
            transition: all 0.1s;
        }

        .crosshair-line {
            position: absolute;
            background-color: #fff;
            box-shadow: 0 0 3px #00ffff, 0 0 6px #00ffff;
            border-radius: 1px;
        }

        .crosshair-horizontal {
            width: 24px;
            height: 2px;
            top: 11px;
            left: 0;
        }

        .crosshair-vertical {
            width: 2px;
            height: 24px;
            top: 0;
            left: 11px;
        }

        .crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #fff;
            border-radius: 50%;
            top: 10px;
            left: 10px;
            box-shadow: 0 0 3px #00ffff, 0 0 6px #00ffff;
        }

        #weaponHUD {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 12px;
            border-radius: 10px;
            border: 2px solid #444;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
        }

        .weapon-hud-slot {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #1a1a2a 0%, #2a2a3a 100%);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            pointer-events: auto;
        }

        .weapon-hud-slot.active {
            border-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
            background: linear-gradient(135deg, #2a2a3a 0%, #3a3a4a 100%);
            transform: scale(1.1);
        }

        .weapon-hud-icon {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 2px;
            text-shadow: 0 0 5px #00ffff;
        }

        .weapon-hud-key {
            font-size: 9px;
            color: #888;
            background: #222;
            padding: 1px 4px;
            border-radius: 3px;
            border: 1px solid #444;
        }

        .weapon-hud-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 0, 0.6);
            transition: height 0.1s;
        }

        .weapon-hud-overheat {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: #ff5500;
        }

        #abilityContainer {
            position: absolute;
            bottom: 180px;
            right: 20px;
            display: flex;
            gap: 8px;
        }

        .ability {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #222 0%, #444 100%);
            border: 2px solid #fff;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #fff;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            font-family: 'Rajdhani', monospace;
        }

        .ability.active {
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }

        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 0, 0, 0.7);
            transition: height 0.3s;
        }

        #comboCounter {
            position: absolute;
            top: 120px;
            left: 20px;
            font-size: 28px;
            color: #ffff00;
            text-shadow: 0 0 10px #ff9900;
            display: none;
            font-weight: bold;
            animation: comboPulse 1s infinite alternate;
            font-family: 'Rajdhani', monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 6px;
            border: 2px solid #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        @keyframes comboPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        #gameOverScreen, #levelCompleteScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.95) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
            backdrop-filter: blur(5px);
        }

        #gameOverText {
            font-size: 96px;
            color: #ff0000;
            margin-bottom: 40px;
            text-shadow: 0 0 30px #ff0000;
            font-weight: bold;
            animation: deathPulse 2s infinite;
            font-family: 'Rajdhani', monospace;
        }

        @keyframes deathPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #levelCompleteText {
            font-size: 96px;
            color: #00ff00;
            margin-bottom: 40px;
            text-shadow: 0 0 30px #00ff00;
            font-weight: bold;
            animation: victoryPulse 1s infinite alternate;
            font-family: 'Rajdhani', monospace;
        }

        @keyframes victoryPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .screenStats {
            font-size: 28px;
            color: #fff;
            margin-bottom: 15px;
            text-align: center;
            font-family: 'Rajdhani', monospace;
        }

        #restartButton, #nextLevelButton {
            padding: 20px 50px;
            font-size: 28px;
            background: linear-gradient(135deg, #222 0%, #444 100%);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 40px;
            pointer-events: auto;
            font-family: 'Rajdhani', monospace;
        }

        #restartButton:hover, #nextLevelButton:hover {
            background: linear-gradient(135deg, #333 0%, #555 100%);
            transform: scale(1.05);
            box-shadow: 0 0 20px #fff;
        }

        #levelTransition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 90;
            display: none;
            backdrop-filter: blur(5px);
        }

        #levelTitle {
            font-size: 64px;
            color: #ffff00;
            margin-bottom: 30px;
            text-shadow: 0 0 15px #ff9900;
            text-align: center;
            animation: titleGlow 2s infinite alternate;
            font-family: 'Rajdhani', monospace;
        }

        #levelDescription {
            font-size: 24px;
            color: #fff;
            max-width: 800px;
            text-align: center;
            margin-bottom: 50px;
            line-height: 1.6;
            padding: 0 20px;
            font-family: 'Rajdhani', monospace;
        }

        #levelStats {
            display: flex;
            gap: 50px;
            margin-bottom: 50px;
        }

        .level-stat {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 2px solid #ffff00;
            min-width: 150px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-size: 36px;
            color: #ffff00;
            margin-bottom: 10px;
            font-weight: bold;
            font-family: 'Rajdhani', monospace;
        }

        .stat-label {
            font-size: 18px;
            color: #ccc;
            font-family: 'Rajdhani', monospace;
        }

        #startLevelButton {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(135deg, #222 0%, #444 100%);
            color: #fff;
            border: 2px solid #ffff00;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Rajdhani', monospace;
        }

        #startLevelButton:hover {
            background: linear-gradient(135deg, #333 0%, #555 100%);
            transform: scale(1.05);
            box-shadow: 0 0 20px #ffff00;
        }

        #damageIndicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #bloodOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #loadingText {
            font-size: 42px;
            color: #fff;
            margin-bottom: 40px;
            text-align: center;
            animation: loadingPulse 1.5s infinite alternate;
            font-family: 'Rajdhani', monospace;
        }

        @keyframes loadingPulse {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        #loadingBar {
            width: 500px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }

        #loadingFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #ff0000);
            background-size: 200% 100%;
            transition: width 0.3s;
            animation: loadingGradient 2s infinite linear;
        }

        @keyframes loadingGradient {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        #punchIndicator {
            position: absolute;
            bottom: 150px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #ff9900;
            font-family: 'Rajdhani', monospace;
        }

        .punch-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #444 0%, #666 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid #ff9900;
        }

        #slideIndicator {
            position: absolute;
            bottom: 190px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #00aaff;
            display: none;
            font-family: 'Rajdhani', monospace;
        }

        #weaponWheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            height: 350px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #fff;
            display: none;
            z-index: 30;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.2);
        }

        .weapon-option {
            position: absolute;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #222 0%, #444 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #666;
            font-family: 'Rajdhani', monospace;
        }

        .weapon-option:hover {
            background: linear-gradient(135deg, #333 0%, #555 100%);
            transform: scale(1.15);
        }

        .weapon-option.active {
            background: linear-gradient(135deg, #ffff00 0%, #ff9900 100%);
            color: #000;
            box-shadow: 0 0 20px #ffff00;
            border-color: #ffff00;
        }

        .shockwave {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 4;
        }

        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 14px;
            font-family: monospace;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }

        #doorInteraction {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 8px;
            border: 2px solid #ffff00;
            color: #ffff00;
            font-size: 24px;
            display: none;
            z-index: 25;
            text-align: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.5);
            font-family: 'Rajdhani', monospace;
        }

        #revolverChargeEffect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 100, 255, 0.5) 0%, rgba(0, 100, 255, 0) 70%);
            display: none;
            pointer-events: none;
            z-index: 15;
        }

        #chargeIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
            z-index: 16;
            color: #00aaff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00aaff;
            font-family: 'Rajdhani', monospace;
        }

        #staminaRegenIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
            z-index: 16;
            color: #00aaff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px #00aaff;
            font-family: 'Rajdhani', monospace;
        }

        #rocketFreezeAura {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 170, 255, 0.2) 0%, rgba(0, 170, 255, 0) 70%);
            border: 2px solid rgba(0, 170, 255, 0.5);
            display: none;
            pointer-events: none;
            z-index: 15;
            animation: auraPulse 2s infinite;
        }

        @keyframes auraPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        #bossDashAura {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.4) 0%, rgba(255, 0, 0, 0) 70%);
            display: none;
            pointer-events: none;
            z-index: 15;
            animation: dashAuraPulse 0.5s infinite alternate;
        }

        @keyframes dashAuraPulse {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(1.1); opacity: 0.9; }
        }

        #bossDashTrail {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 14;
            display: none;
        }

        .dash-trail-particle {
            position: absolute;
            background: radial-gradient(circle, #ff3300 0%, #ff0000 100%);
            border-radius: 50%;
            pointer-events: none;
        }

        #bossChargeEffect {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.3) 0%, rgba(255, 0, 0, 0) 70%);
            display: none;
            pointer-events: none;
            z-index: 15;
        }

        .enemy-hit-cooldown {
            background: rgba(255, 0, 0, 0.3);
            border: 1px solid rgba(255, 0, 0, 0.5);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="mainMenu">
        <div id="titleContainer">
            <div id="gameTitle">BLOOD MACHINE</div>
            <div id="gameSubtitle">INFERNO CYCLES</div>
        </div>
        
        <div class="menuButtons">
            <button id="playButton" class="menuButton">JOGAR</button>
            <button id="instructionsButton" class="menuButton">INSTRU√á√ïES</button>
        </div>
    </div>

    <div id="instructionsMenu">
        <div id="instructionsTitle">CONTROLES E MEC√ÇNICAS</div>
        
        <div class="instructionsContainer">
            <div class="instructionSection">
                <div class="sectionTitle">üéÆ MOVIMENTO</div>
                <div class="controlItem">
                    <span class="controlKey">W A S D</span>
                    <span class="controlDescription">Movimenta√ß√£o</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">ESPA√áO</span>
                    <span class="controlDescription">Pular / Dash no ar</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">SHIFT</span>
                    <span class="controlDescription">Dash no ch√£o</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">CTRL</span>
                    <span class="controlDescription">Deslizar / Slam no ar</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">Q</span>
                    <span class="controlDescription">Roda de armas</span>
                </div>
            </div>

            <div class="instructionSection">
                <div class="sectionTitle">üî´ COMBATE</div>
                <div class="controlItem">
                    <span class="controlKey">MOUSE1</span>
                    <span class="controlDescription">Atirar</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">MOUSE2</span>
                    <span class="controlDescription">Arma Especial</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">1 2 3 4 5</span>
                    <span class="controlDescription">Sele√ß√£o r√°pida</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">F</span>
                    <span class="controlDescription">Soco (Recupera Vida)</span>
                </div>
                <div class="controlItem">
                    <span class="controlKey">E</span>
                    <span class="controlDescription">Interagir com Port√µes</span>
                </div>
            </div>

            <div class="instructionSection">
                <div class="sectionTitle">üí• ARMAMENTOS</div>
                <div class="weaponInfo">
                    <div class="weaponIcon" style="background: #00aaff;">1</div>
                    <div>
                        <strong>REVOLVER</strong><br>
                        Tiro √önico | Raio Carreg√°vel
                    </div>
                </div>
                <div class="weaponInfo">
                    <div class="weaponIcon" style="background: #ff5500;">2</div>
                    <div>
                        <strong>SHOTGUN</strong><br>
                        Tiro Disperso | Explos√£o de Cartuchos
                    </div>
                </div>
                <div class="weaponInfo">
                    <div class="weaponIcon" style="background: #00aaff;">3</div>
                    <div>
                        <strong>NAILGUN</strong><br>
                        Tiro r√°pido | √çm√£ magn√©tico
                    </div>
                </div>
                <div class="weaponInfo">
                    <div class="weaponIcon" style="background: #0066ff;">4</div>
                    <div>
                        <strong>RAILGUN</strong><br>
                        Tiro Poderoso e √önico | Atravessa Tudo
                    </div>
                </div>
                <div class="weaponInfo">
                    <div class="weaponIcon" style="background: #ff8800;">5</div>
                    <div>
                        <strong>ROCKET LAUNCHER</strong><br>
                        Foguete Explosivo | Congelamento
                    </div>
                </div>
            </div>

            <div class="instructionSection">
                <div class="sectionTitle">‚ö° MEC√ÇNICAS</div>
                <div style="color: #ccc; line-height: 1.6;">
                    <p>‚Ä¢ <strong>WALL RUNNING</strong>: Pressione contra paredes para correr</p>
                    <p>‚Ä¢ <strong>SLAM A√âREO</strong>: CTRL no ar causa dano em √°rea</p>
                    
                    <p>‚Ä¢ <strong>RECUPERA√á√ÉO POR SOCOS</strong>: Socar inimigos recupera vida</p>
                    <p>‚Ä¢ <strong>DASH EM 3 PARTES</strong>: Gerencie sua stamina de dash</p>
                    
                </div>
            </div>
        </div>
        
        <button id="backButton">VOLTAR</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="uiContainer">
            <div id="resourceContainer">
                <div id="healthBar">
                    <div id="healthFill"></div>
                    <div id="healthText">HEALTH</div>
                </div>
                <div id="staminaContainer">
                    <div id="staminaLabel">DASH STAMINA</div>
                    <div id="staminaBars">
                        <div class="stamina-segment" id="staminaSegment1">
                            <div class="stamina-fill"></div>
                        </div>
                        <div class="stamina-segment" id="staminaSegment2">
                            <div class="stamina-fill"></div>
                        </div>
                        <div class="stamina-segment" id="staminaSegment3">
                            <div class="stamina-fill"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="scoreContainer">
                <div id="scoreDisplay">SCORE: 0</div>
                <div id="styleRank">D</div>
            </div>

            <div id="stylePointsContainer"></div>
            
            <div id="weaponContainer">
                <div id="weaponInfo">
                    <div id="weaponName">REVOLVER</div>
                    <div id="weaponCooldown">READY</div>
                    <div id="weaponSpecial">SPECIAL: HOLD TO CHARGE</div>
                </div>
            </div>
            
            <div id="weaponHUD">
                <div class="weapon-hud-slot active" data-weapon="0">
                    <div class="weapon-hud-icon">‚ö°</div>
                    <div class="weapon-hud-key">1</div>
                    <div class="weapon-hud-cooldown"></div>
                </div>
                <div class="weapon-hud-slot" data-weapon="1">
                    <div class="weapon-hud-icon">üí•</div>
                    <div class="weapon-hud-key">2</div>
                    <div class="weapon-hud-cooldown"></div>
                </div>
                <div class="weapon-hud-slot" data-weapon="2">
                    <div class="weapon-hud-icon">üî©</div>
                    <div class="weapon-hud-key">3</div>
                    <div class="weapon-hud-cooldown"></div>
                    <div class="weapon-hud-overheat"></div>
                </div>
                <div class="weapon-hud-slot" data-weapon="3">
                    <div class="weapon-hud-icon">üåÄ</div>
                    <div class="weapon-hud-key">4</div>
                    <div class="weapon-hud-cooldown"></div>
                </div>
                <div class="weapon-hud-slot" data-weapon="4">
                    <div class="weapon-hud-icon">üöÄ</div>
                    <div class="weapon-hud-key">5</div>
                    <div class="weapon-hud-cooldown"></div>
                </div>
            </div>
            
            <div id="styleMeter">
                <div id="styleFill"></div>
                <div id="styleText">D - DEMIURGO</div>
            </div>
            
            <div id="enemyHealthContainer">
                <div id="enemyName">STALKER</div>
                <div id="enemyHealthBar">
                    <div id="enemyHealthFill"></div>
                </div>
            </div>
            
            <div id="crosshair">
                <div class="crosshair-line crosshair-horizontal"></div>
                <div class="crosshair-line crosshair-vertical"></div>
                <div class="crosshair-dot"></div>
            </div>

            <div id="punchIndicator">
                <div class="punch-icon">F</div>
                <div>Soco - Recupera Vida de Inimigos Pr√≥ximos</div>
            </div>

            <div id="slideIndicator">
                <div class="punch-icon" style="border-color: #00aaff;">‚Üì</div>
                <div>Deslizando - Mantenha CTRL para continuar</div>
            </div>

            <div id="abilityContainer">
                <div class="ability" id="timeSlowAbility">
                    <div class="ability-cooldown"></div>
                    T
                </div>
                <div class="ability" id="bloodRageAbility">
                    <div class="ability-cooldown"></div>
                    R
                </div>
            </div>

            <div id="comboCounter">COMBO: 0x</div>

            <div id="bloodOverlay"></div>
        </div>
        
        <div id="gameOverScreen">
            <div id="gameOverText">MORTO</div>
            <div class="screenStats" id="finalScore">SCORE: 0</div>
            <div class="screenStats" id="finalStyle">ESTILO M√ÅXIMO: D</div>
            <div class="screenStats" id="killCount">INIMIGOS ELIMINADOS: 0</div>
            <div class="screenStats" id="maxCombo">COMBO M√ÅXIMO: 0x</div>
            <button id="restartButton">REINICIAR N√çVEL</button>
        </div>
        
        <div id="levelCompleteScreen">
            <div id="levelCompleteText">N√çVEL COMPLETO</div>
            <div class="screenStats" id="levelScore">SCORE: 0</div>
            <div class="screenStats" id="styleAchieved">ESTILO M√ÅXIMO: D</div>
            <div class="screenStats" id="levelKills">INIMIGOS ELIMINADOS: 0</div>
            <div class="screenStats" id="levelTime">TEMPO: 0:00</div>
            <div class="screenStats" id="levelCombo">COMBO M√ÅXIMO: 0x</div>
            <button id="nextLevelButton">PR√ìXIMO N√çVEL</button>
        </div>
        
        <div id="levelTransition">
            <div id="levelTitle">N√çVEL 1: A ENTRADA DO INFERNO</div>
            <div id="levelDescription">Penetre nas profundezas do inferno e elimine todas as amea√ßas. Use seu arsenal para criar combos e aumentar seu estilo. Encontre e destrua o n√∫cleo infernal para progredir.</div>
            <div id="levelStats">
                <div class="level-stat">
                    <div class="stat-value" id="levelEnemies">20</div>
                    <div class="stat-label">INIMIGOS</div>
                </div>
                <div class="level-stat">
                    <div class="stat-value" id="levelSecrets">5</div>
                    <div class="stat-label">SEGREDOS</div>
                </div>
                <div class="level-stat">
                    <div class="stat-value" id="levelDifficulty">M√âDIO</div>
                    <div class="stat-label">DIFICULDADE</div>
                </div>
            </div>
            <button id="startLevelButton">INICIAR N√çVEL</button>
        </div>
        
        <div id="weaponWheel">
            <div class="weapon-option" data-weapon="0" style="top: 30px; left: 135px;">1</div>
            <div class="weapon-option" data-weapon="1" style="top: 135px; left: 250px;">2</div>
            <div class="weapon-option" data-weapon="2" style="top: 250px; left: 135px;">3</div>
            <div class="weapon-option" data-weapon="3" style="top: 135px; left: 30px;">4</div>
            <div class="weapon-option" data-weapon="4" style="top: 250px; left: 30px;">5</div>
        </div>
        
        <div id="damageIndicator"></div>
        
        <div id="loadingScreen">
            <div id="loadingText">CARREGANDO BLOOD MACHINE: INFERNO CYCLES...</div>
            <div id="loadingBar">
                <div id="loadingFill"></div>
            </div>
        </div>

        <div id="fpsCounter">FPS: 60</div>

        <div id="doorInteraction">
            Interagir - E
        </div>

        <div id="revolverChargeEffect"></div>
        <div id="chargeIndicator"></div>

        <div id="staminaRegenIndicator"></div>

        <div id="rocketFreezeAura"></div>

        <div id="bossDashAura"></div>
        <div id="bossDashTrail"></div>
        <div id="bossChargeEffect"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let gameState = {
            currentLevel: 1,
            player: {
                x: 100,
                y: 300,
                width: 50,
                height: 80,
                velocityX: 0,
                velocityY: 0,
                speed: 6,
                jumpPower: 16,
                health: 100,
                maxHealth: 100,
                stamina: 3,
                maxStamina: 3,
                staminaCooldown: 0,
                staminaRegenTimer: 0,
                isGrounded: false,
                isDashing: false,
                dashCooldown: 0,
                dashDuration: 0,
                canAirDash: true,
                weapons: [
                    { 
                        name: 'Revolver', 
                        cooldown: 0, 
                        maxCooldown: 30,
                        special: 'Charge Beam', 
                        specialCooldown: 0,
                        maxSpecialCooldown: 240,
                        color: '#00aaff',
                        bulletColor: '#00aaff',
                        specialColor: '#0066ff',
                        charging: false,
                        chargeTime: 0,
                        chargeReady: false,
                        chargeCooldown: 0,
                        canShowCharge: true
                    },
                    { 
                        name: 'Shotgun', 
                        cooldown: 0, 
                        maxCooldown: 90,
                        special: 'Explosive Shell', 
                        specialCooldown: 0,
                        maxSpecialCooldown: 300,
                        color: '#ff5500',
                        bulletColor: '#ff5500',
                        specialColor: '#ff3300'
                    },
                    { 
                        name: 'Nailgun', 
                        cooldown: 0, 
                        maxCooldown: 5,
                        special: 'Magnet Nail', 
                        specialCooldown: 0,
                        maxSpecialCooldown: 180,
                        color: '#00aaff',
                        bulletColor: '#00aaff',
                        specialColor: '#0066ff',
                        shotsFired: 0,
                        maxShots: 30,
                        overheatCooldown: 0,
                        maxOverheatCooldown: 600
                    },
                    { 
                        name: 'Railgun', 
                        cooldown: 0, 
                        maxCooldown: 960,
                        special: null,
                        specialCooldown: 0,
                        maxSpecialCooldown: 0,
                        color: '#0066ff',
                        bulletColor: '#0066ff',
                        specialColor: '#00ffff',
                        pierce: true,
                        pierceCount: 999,
                        pierceWalls: true
                    },
                    { 
                        name: 'Rocket Launcher', 
                        cooldown: 0, 
                        maxCooldown: 90,
                        special: 'Remote Detonate', 
                        specialCooldown: 0,
                        maxSpecialCooldown: 1,
                        color: '#ff8800',
                        bulletColor: '#ff8800',
                        specialColor: '#ff5500',
                        activeRockets: [],
                        frozenRockets: false,
                        freezeTime: 0,
                        freezeActive: false,
                        freezeDuration: 0,
                        maxFreezeDuration: 600,
                        freezeCooldown: 0
                    }
                ],
                currentWeapon: 0,
                sliding: false,
                slideTime: 0,
                slideDirection: 0,
                wallRunning: false,
                wallRunSide: 0,
                wallRunTime: 0,
                abilities: {
                    timeSlow: { active: false, duration: 0, cooldown: 0, maxCooldown: 300 },
                    bloodRage: { active: false, duration: 0, cooldown: 0, maxCooldown: 480 }
                },
                bloodRageMultiplier: 1,
                coins: 0,
                punchCooldown: 0,
                maxPunchCooldown: 150,
                punchDamage: 35,
                punchRange: 120,
                lastPunchHit: 0,
                punchHealAmount: 10,
                lastTrapDamage: 0,
                lastEnemyCollisionDamage: 0,
                trapDamageCooldown: 1500,
                enemyCollisionCooldown: 1500
            },
            enemies: [],
            bullets: [],
            particles: [],
            magnetNails: [],
            orbitingNails: [],
            platforms: [],
            obstacles: [],
            decorations: [],
            pickups: [],
            bossDoors: [],
            currentBoss: null,
            bossActive: false,
            bossSpawned: false,
            bossDoorActive: false,
            score: 0,
            stylePoints: 0,
            styleRank: 'D',
            styleMultiplier: 1,
            lastKillTime: 0,
            comboTime: 3000,
            killCombo: 0,
            maxCombo: 0,
            styleEvents: [],
            gameOver: false,
            levelComplete: false,
            keys: {},
            mouse: {
                x: 0,
                y: 0,
                pressed: false,
                rightPressed: false,
                rightPressedTime: 0,
                lastRightClick: 0
            },
            camera: {
                x: 0,
                y: 0,
                shake: 0,
                shakeIntensity: 0
            },
            currentEnemyTarget: null,
            aimMode: 'free',
            killCount: 0,
            levelStartTime: 0,
            levelTime: 0,
            showWeaponWheel: false,
            timeScale: 1,
            goreEnabled: true,
            mapBottomLimit: 1500,
            backgrounds: [],
            backgroundParticles: [],
            fps: 60,
            lastFrameTime: 0,
            shockwaves: [],
            bossBarriers: [],
            enemyHitCooldowns: new Map(),
            bossDashTrail: [],
            bossChargeTime: 0,
            bossChargingDash: false,
            bossLastDash: 0,
            bossDashCooldown: 20000
        };

        const levels = [
            {
                name: "A ENTRADA DO INFERNO",
                description: "Penetre nas profundezas do inferno e elimine todas as amea√ßas. Encontre e abra o port√£o do boss para enfrentar o Cerberus. Derrote-o para abrir o portal para a pr√≥xima fase.",
                platforms: [
                    { x: 0, y: 700, width: 1200, height: 40, type: 'ground', texture: 'hell_ground', solid: true },
                    { x: 1300, y: 650, width: 300, height: 30, type: 'platform', texture: 'hell_platform', solid: true },
                    { x: 1700, y: 600, width: 300, height: 30, type: 'platform', texture: 'hell_platform', solid: true },
                    { x: 2100, y: 550, width: 300, height: 30, type: 'platform', texture: 'hell_platform', solid: true },
                    { x: 2500, y: 600, width: 400, height: 30, type: 'platform', texture: 'hell_platform', solid: true },
                    { x: 3000, y: 700, width: 2000, height: 40, type: 'ground', texture: 'hell_ground', solid: true },
                    
                    { x: 600, y: 550, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                    { x: 900, y: 500, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                    { x: 1200, y: 450, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                    { x: 1500, y: 400, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                   
                    { x: 2300, y: 400, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                    { x: 2700, y: 450, width: 160, height: 25, type: 'floating', texture: 'hell_floating', solid: true },
                    
                    { x: 500, y: 400, width: 40, height: 300, type: 'wall', texture: 'hell_wall', solid: true, topSolid: true },
                    { x: 1200, y: 350, width: 40, height: 350, type: 'wall', texture: 'hell_wall', solid: true, topSolid: true },
                    { x: 2000, y: 300, width: 40, height: 250, type: 'wall', texture: 'hell_wall', solid: true, topSolid: true },
                    { x: 2600, y: 400, width: 40, height: 250, type: 'wall', texture: 'hell_wall', solid: true, topSolid: true },
                    
                    
                ],
                obstacles: [
                     { x: 350, y: 680, width: 60, height: 20, type: 'spike', solid: true },
                      { x: 550, y: 680, width: 60, height: 20, type: 'spike', solid: true },
                      { x: 750, y: 680, width: 60, height: 20, type: 'spike', solid: true },

                      // Po√ßos de lava organizados
                      { x: 1400, y: 630, width: 50, height: 20, type: 'lava_pit', solid: false },
                      { x: 1800, y: 580, width: 50, height: 20, type: 'lava_pit', solid: false },
                      { x: 2300, y: 540, width: 80, height: 20, type: 'lava_pit', solid: false },

                      // Armadilhas antes do boss
                      { x: 2800, y: 580, width: 100, height: 20, type: 'spike', solid: true },
                      { x: 3000, y: 680, width: 100, height: 20, type: 'spike', solid: true }
                                  ],
                decorations: [
                    { x: 200, y: 650, width: 50, height: 50, type: 'skull_pile' },
    { x: 600, y: 650, width: 50, height: 50, type: 'skull_pile' },
    { x: 1000, y: 650, width: 50, height: 50, type: 'skull_pile' },
    { x: 3700, y: 660, width: 50, height: 50, type: 'skull_pile' },
    { x: 3200, y: 660, width: 50, height: 50, type: 'skull_pile' },
    { x: 4500, y: 660, width: 50, height: 50, type: 'skull_pile' },
    
    // Pilares infernais
    { x: 800, y: 600, width: 80, height: 100, type: 'hell_pillar' },
    { x: 1300, y: 550, width: 80, height: 100, type: 'hell_pillar' },

    { x: 250, y: 500, width: 100, height: 200, type: 'hell_statue' },
    { x: 1500, y: 450, width: 100, height: 200, type: 'hell_statue' },
    { x: 3000, y: 400, width: 100, height: 300, type: 'hell_statue' },
    { x: 4700, y: 400, width: 100, height: 300, type: 'hell_statue' }
                ],
                pickups: [
                    { x: 600, y: 650, type: 'health', value: 25 },
                    { x: 1000, y: 450, type: 'coin', value: 100 },
                    { x: 1700, y: 550, type: 'health', value: 25 },
                    { x: 2300, y: 450, type: 'coin', value: 100 },
                    { x: 2900, y: 550, type: 'health', value: 25 }
                ],
                enemySpawns: [
                    { type: 'husk', x: 400, y: 650 },
                    { type: 'husk', x: 650, y: 650 },
                    { type: 'husk', x: 650, y: 650 },
                    { type: 'husk', x: 650, y: 650 },
                    { type: 'soldier', x: 850, y: 650 },
                    { type: 'husk', x: 1150, y: 650 },
                    { type: 'soldier', x: 1450, y: 550 },
                    { type: 'machine', x: 1750, y: 500 },
                    { type: 'husk', x: 2050, y: 500 },
                    { type: 'soldier', x: 2350, y: 450 },
                    { type: 'machine', x: 2650, y: 450 },
                    { type: 'machine', x: 2750, y: 450 },
                    { type: 'husk', x: 2950, y: 400 },
                    { type: 'soldier', x: 3250, y: 400 },
                    { type: 'machine', x: 3550, y: 550 },
                    { type: 'husk', x: 3850, y: 550 },
                    { type: 'machine', x: 3650, y: 450 },
                    { type: 'soldier', x: 4150, y: 550 },
                    { type: 'machine', x: 4450, y: 550 }
                ],
                bossDoor: { x: 4000, y: 550, width: 140, height: 200, type: 'boss_gate', bossType: 'cerberus' },
                bossSpawn: { x: 4700, y: 550 },
                goal: { x: 5100, y: 600, width: 70, height: 70, type: 'core', active: false },
                enemyCount: 15,
                secretCount: 5,
                difficulty: 'M√âDIO',
                background: 'hell_entrance'
            },
            {
                name: "A FORJA DE SANGUE",
                description: "Avan√ße atrav√©s das fundi√ß√µes infernais onde armas demon√≠acas s√£o forjadas. Enfrente o tem√≠vel Dem√¥nio da Forja para progredir.",
                platforms: [
                    { x: 0, y: 700, width: 700, height: 40, type: 'ground', texture: 'forge_ground', solid: true },
                    { x: 800, y: 650, width: 280, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 1200, y: 600, width: 280, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 1600, y: 550, width: 280, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 2000, y: 650, width: 380, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 2500, y: 700, width: 550, height: 40, type: 'ground', texture: 'forge_ground', solid: true },
                    { x: 3200, y: 650, width: 280, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 3600, y: 600, width: 280, height: 30, type: 'platform', texture: 'forge_platform', solid: true },
                    { x: 4000, y: 700, width: 700, height: 40, type: 'ground', texture: 'forge_ground', solid: true },
                    
                    { x: 950, y: 500, width: 140, height: 25, type: 'moving', startX: 950, endX: 1150, speed: 1.5, texture: 'forge_moving', solid: true },
                    { x: 1750, y: 400, width: 140, height: 25, type: 'moving', startX: 1750, endX: 1950, speed: 2, texture: 'forge_moving', solid: true },
                    { x: 3300, y: 500, width: 140, height: 25, type: 'moving', startX: 3300, endX: 3500, speed: 1.8, texture: 'forge_moving', solid: true },
                    
                    { x: 700, y: 400, width: 40, height: 300, type: 'wall', texture: 'forge_wall', solid: true, topSolid: true },
                    { x: 1400, y: 350, width: 40, height: 300, type: 'wall', texture: 'forge_wall', solid: true, topSolid: true },
                    { x: 2400, y: 550, width: 40, height: 150, type: 'wall', texture: 'forge_wall', solid: true, topSolid: true },
                    { x: 3300, y: 400, width: 40, height: 250, type: 'wall', texture: 'forge_wall', solid: true, topSolid: true },
                    
                    { x: 4700, y: 300, width: 1000, height: 400, type: 'boss_arena', texture: 'boss_arena', solid: true }
                ],
                obstacles: [
                    { x: 350, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 650, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 1050, y: 630, width: 45, height: 20, type: 'forge_fire', solid: false },
                    { x: 1550, y: 530, width: 45, height: 20, type: 'forge_fire', solid: false },
                    { x: 2250, y: 630, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 2750, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 3250, y: 630, width: 45, height: 20, type: 'forge_fire', solid: false },
                    { x: 3850, y: 530, width: 45, height: 20, type: 'forge_fire', solid: false },
                ],
                decorations: [
                    { x: 350, y: 660, width: 70, height: 55, type: 'forge_anvil' },
                    { x: 750, y: 660, width: 70, height: 55, type: 'forge_anvil' },
                    { x: 1350, y: 570, width: 70, height: 55, type: 'forge_furnace' },
                    { x: 2150, y: 570, width: 70, height: 55, type: 'forge_anvil' },
                    { x: 2950, y: 660, width: 70, height: 55, type: 'forge_furnace' },
                    { x: 3750, y: 520, width: 70, height: 55, type: 'forge_anvil' },
                    { x: 4350, y: 660, width: 90, height: 110, type: 'forge_statue' },
                ],
                pickups: [
                    { x: 800, y: 600, type: 'health', value: 25 },
                    { x: 1400, y: 350, type: 'coin', value: 150 },
                    { x: 2200, y: 550, type: 'coin', value: 150 },
                    { x: 3050, y: 500, type: 'health', value: 50 },
                    { x: 3850, y: 550, type: 'health', value: 50 },
                    { x: 4650, y: 650, type: 'health', value: 75 }
                ],
                enemySpawns: [
                    { type: 'soldier', x: 550, y: 650 },
                    { type: 'machine', x: 800, y: 600 },
                    { type: 'husk', x: 1150, y: 550 },
                    { type: 'soldier', x: 1450, y: 500 },
                    { type: 'machine', x: 1750, y: 450 },
                    { type: 'soldier', x: 2000, y: 600 },
                    { type: 'husk', x: 2250, y: 650 },
                    { type: 'machine', x: 2550, y: 600 },
                    { type: 'soldier', x: 2800, y: 550 },
                    { type: 'husk', x: 3100, y: 500 },
                    { type: 'machine', x: 3400, y: 500 },
                    { type: 'soldier', x: 3700, y: 600 },
                    { type: 'husk', x: 4000, y: 650 },
                    { type: 'machine', x: 4300, y: 600 },
                    { type: 'soldier', x: 4600, y: 650 },
                    { type: 'husk', x: 4900, y: 600 },
                    { type: 'machine', x: 5200, y: 550 }
                ],
                bossDoor: { x: 4500, y: 550, width: 140, height: 200, type: 'boss_gate', bossType: 'forge_demon' },
                bossSpawn: { x: 5200, y: 550 },
                goal: { x: 5600, y: 600, width: 70, height: 70, type: 'core', active: false },
                enemyCount: 17,
                secretCount: 6,
                difficulty: 'DIF√çCIL',
                background: 'blood_forge'
            },
            {
                name: "A CATEDRAL CARMESIM",
                description: "O santu√°rio final onde o arquidem√¥nio aguarda. Prepare-se para o combate mais intenso de sua exist√™ncia.",
                platforms: [
                    { x: 0, y: 700, width: 450, height: 40, type: 'ground', texture: 'cathedral_ground', solid: true },
                    { x: 550, y: 650, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 950, y: 600, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 1350, y: 550, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 1750, y: 500, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 2150, y: 650, width: 380, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 2650, y: 700, width: 550, height: 40, type: 'ground', texture: 'cathedral_ground', solid: true },
                    { x: 3350, y: 650, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 3750, y: 600, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 4150, y: 550, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 4550, y: 500, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 4950, y: 450, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 5350, y: 700, width: 700, height: 40, type: 'ground', texture: 'cathedral_ground', solid: true },
                    { x: 6250, y: 650, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 6650, y: 600, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 7050, y: 550, width: 280, height: 30, type: 'platform', texture: 'cathedral_platform', solid: true },
                    { x: 7450, y: 700, width: 700, height: 40, type: 'ground', texture: 'cathedral_ground', solid: true },
                    
                    { x: 650, y: 500, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 1050, y: 450, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 1450, y: 400, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 1850, y: 450, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 2450, y: 500, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 2850, y: 450, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 3250, y: 400, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 3650, y: 350, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 4050, y: 300, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 4450, y: 250, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 5450, y: 500, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 5850, y: 450, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 6250, y: 400, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 6650, y: 350, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    { x: 7050, y: 300, width: 90, height: 25, type: 'floating', texture: 'cathedral_floating', solid: true },
                    
                    { x: 450, y: 400, width: 45, height: 300, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 1250, y: 350, width: 45, height: 250, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 2150, y: 450, width: 45, height: 150, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 2950, y: 400, width: 45, height: 250, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 3750, y: 300, width: 45, height: 200, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 4550, y: 450, width: 45, height: 150, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 5750, y: 400, width: 45, height: 250, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 6550, y: 350, width: 45, height: 200, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    { x: 7350, y: 450, width: 45, height: 150, type: 'wall', texture: 'cathedral_wall', solid: true, topSolid: true },
                    
                    { x: 7850, y: 300, width: 1000, height: 400, type: 'boss_arena', texture: 'boss_arena', solid: true }
                ],
                obstacles: [
                    { x: 300, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 800, y: 630, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 1400, y: 530, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 2100, y: 630, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 2700, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 3300, y: 630, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 3900, y: 530, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 4600, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 5200, y: 630, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 5800, y: 530, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                    { x: 6500, y: 680, width: 70, height: 20, type: 'spike', solid: true },
                    { x: 7100, y: 630, width: 55, height: 20, type: 'cathedral_trap', solid: false },
                ],
                decorations: [
                    { x: 200, y: 660, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 1100, y: 520, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 2000, y: 620, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 2800, y: 660, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 3600, y: 470, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 4400, y: 620, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 5450, y: 660, width: 110, height: 150, type: 'cathedral_altar' },
                    { x: 6200, y: 520, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 7000, y: 620, width: 70, height: 90, type: 'cathedral_statue' },
                    { x: 7800, y: 660, width: 110, height: 150, type: 'cathedral_altar' },
                ],
                pickups: [
                    { x: 700, y: 450, type: 'health', value: 50 },
                    { x: 1300, y: 350, type: 'coin', value: 200 },
                    { x: 2100, y: 500, type: 'coin', value: 200 },
                    { x: 2900, y: 400, type: 'health', value: 50 },
                    { x: 3700, y: 300, type: 'health', value: 50 },
                    { x: 4500, y: 600, type: 'health', value: 100 },
                    { x: 5300, y: 650, type: 'health', value: 100 },
                    { x: 6100, y: 350, type: 'coin', value: 250 },
                    { x: 6900, y: 450, type: 'health', value: 75 },
                    { x: 7700, y: 600, type: 'health', value: 150 }
                ],
                enemySpawns: [
                    { type: 'machine', x: 600, y: 600 },
                    { type: 'soldier', x: 900, y: 550 },
                    { type: 'machine', x: 1300, y: 500 },
                    { type: 'soldier', x: 1700, y: 450 },
                    { type: 'machine', x: 2000, y: 550 },
                    { type: 'soldier', x: 2300, y: 650 },
                    { type: 'machine', x: 2700, y: 600 },
                    { type: 'soldier', x: 3100, y: 550 },
                    { type: 'machine', x: 3500, y: 500 },
                    { type: 'soldier', x: 3900, y: 450 },
                    { type: 'machine', x: 4300, y: 400 },
                    { type: 'soldier', x: 4700, y: 400 },
                    { type: 'machine', x: 5000, y: 450 },
                    { type: 'soldier', x: 5300, y: 500 },
                    { type: 'machine', x: 5600, y: 550 },
                    { type: 'soldier', x: 6000, y: 600 },
                    { type: 'machine', x: 6400, y: 550 },
                    { type: 'soldier', x: 6800, y: 500 },
                    { type: 'machine', x: 7200, y: 450 },
                    { type: 'soldier', x: 7600, y: 500 },
                    { type: 'machine', x: 8000, y: 550 },
                    { type: 'soldier', x: 8400, y: 600 },
                    { type: 'machine', x: 8800, y: 550 }
                ],
                bossDoor: { x: 7650, y: 550, width: 140, height: 200, type: 'boss_gate', bossType: 'archdemon' },
                bossSpawn: { x: 8350, y: 550 },
                goal: { x: 8750, y: 600, width: 70, height: 70, type: 'core', active: false },
                enemyCount: 23,
                secretCount: 10,
                difficulty: 'INSANO',
                background: 'crimson_cathedral'
            }
        ];

        const bossTypes = {
            cerberus: {
                name: "CERBERUS",
                width: 180,
                height: 240,
                health: 1500,
                maxHealth: 1500,
                speed: 2.2,
                damage: 60,
                color: '#8B4513',
                stoneColor: '#696969',
                muscleColor: '#8B7355',
                attackRange: 9999,
                attackCooldown: 1000,
                lastAttack: 0,
                points: 3000,
                behavior: 'boss',
                goreChunks: 25,
                design: 'cerberus',
                headRadius: 40,
                bodyWidth: 160,
                bodyHeight: 180,
                specialAttacks: ['triple_fireball', 'charge', 'ground_slam', 'summon_hellhounds', 'dash_attack', 'charged_beam'],
                specialAttackCooldown: 0,
                phase: 1,
                phaseThreshold: 0.5,
                dashCharging: false,
                dashChargeTime: 0,
                dashCharged: false,
                lastDashTime: 0,
                dashSpeed: 30,
                dashDamage: 25,
                dashKnockback: 30,
                chargedBeamCharging: false,
                chargedBeamChargeTime: 0,
                chargedBeamCharged: false,
                lastChargedBeamTime: 0,
                chargedBeamCooldown: 1800
                
            },
            forge_demon: {
                name: "DEM√îNIO DA FORJA",
                width: 160,
                height: 230,
                health: 3500,
                maxHealth: 3500,
                speed: 1.2,
                damage: 60,
                color: '#aa3300',
                attackRange: 500,
                attackCooldown: 1400,
                lastAttack: 0,
                points: 5000,
                behavior: 'boss',
                goreChunks: 25,
                design: 'forge_demon',
                hammerWidth: 60,
                hammerHeight: 90,
                bodyWidth: 130,
                bodyHeight: 160,
                specialAttacks: ['hammer_slam', 'fire_wave', 'meteor_shower', 'forge_explosion'],
                specialAttackCooldown: 0,
                phase: 1,
                phaseThreshold: 0.4
            },
            archdemon: {
                name: "ARQUIDEM√îNIO",
                width: 180,
                height: 260,
                health: 5000,
                maxHealth: 5000,
                speed: 1.0,
                damage: 75,
                color: '#330000',
                attackRange: 550,
                attackCooldown: 1600,
                lastAttack: 0,
                points: 8000,
                behavior: 'finalBoss',
                goreChunks: 30,
                design: 'archdemon',
                crownHeight: 50,
                bodyWidth: 150,
                bodyHeight: 190,
                wingSpan: 250,
                specialAttacks: ['dark_energy', 'teleport_strike', 'doom_beam', 'apocalypse', 'chain_lightning', 'void_vortex'],
                specialAttackCooldown: 0,
                phase: 1,
                phaseThreshold: 0.3
            }
        };

        const enemyTypes = {
            husk: {
                width: 40,
                height: 60,
                health: 60,
                speed: 4.8,
                damage: 20,
                color: '#4a4a4a',
                bodyColor: '#666666',
                detailColor: '#8b4513',
                attackRange: 50,
                attackCooldown: 800,
                lastAttack: 0,
                points: 150,
                behavior: 'melee',
                goreChunks: 100,
                design: 'husk',
                headRadius: 10,
                bodyWidth: 30,
                bodyHeight: 35,
                patrolSpeed: 3.2,
                patrolRange: 200,
                melee: true
            },
            soldier: {
                width: 50,
                height: 75,
                health: 220,
                speed: 2.5,
                damage: 15,
                color: '#FF4500',
                armorColor: '#777777',
                detailColor: '#333333',
                attackRange: 400,
                attackCooldown: 1500,
                lastAttack: 0,
                points: 250,
                behavior: 'ranged',
                goreChunks: 112,
                design: 'soldier',
                helmetHeight: 20,
                bodyWidth: 40,
                bodyHeight: 45,
                visorColor: '#222222',
                patrolSpeed: 1.5,
                patrolRange: 150,
                shotCount: 3,
                shotSpread: 0.2
            },
            machine: {
                width: 60,
                height: 85,
                health: 130,
                speed: 2.52,
                damage: 10,
                color: '#FF4500',
                metalColor: '#444444',
                glowColor: '#00aaff',
                attackRange: 450,
                attackCooldown: 500,
                lastAttack: 0,
                points: 400,
                behavior: 'evasive',
                goreChunks: 115,
                design: 'machine',
                eyeRadius: 6,
                bodyWidth: 50,
                bodyHeight: 60,
                detailColor: '#111111',
                patrolSpeed: 1.68,
                patrolRange: 100,
                evasionSpeed: 2.52
            }
        };

        const backgroundTypes = {
            hell_entrance: {
                gradient: {
                    start: '#0a0a2a',
                    end: '#1a1a3a'
                },
                mountains: {
                    color: '#1a1a4a',
                    count: 10,
                    minHeight: 120,
                    maxHeight: 220,
                    spacing: 350
                },
                buildings: {
                    color: '#2a1a1a',
                    count: 15,
                    minHeight: 100,
                    maxHeight: 200,
                    spacing: 300
                },
                particles: {
                    color: '#ff3333',
                    count: 70,
                    size: 1.8,
                    speed: 0.4
                },
                fog: {
                    color: 'rgba(100, 0, 0, 0.15)',
                    layers: 4
                },
                lava: false
            },
            blood_forge: {
                gradient: {
                    start: '#2a0a0a',
                    end: '#3a1a1a'
                },
                mountains: {
                    color: '#3a1a2a',
                    count: 12,
                    minHeight: 140,
                    maxHeight: 240,
                    spacing: 320
                },
                buildings: {
                    color: '#3a1a1a',
                    count: 18,
                    minHeight: 120,
                    maxHeight: 220,
                    spacing: 280
                },
                particles: {
                    color: '#ff5555',
                    count: 80,
                    size: 2.2,
                    speed: 0.6
                },
                fog: {
                    color: 'rgba(150, 50, 0, 0.25)',
                    layers: 5
                },
                lava: true,
                lavaColor: '#ff3300',
                lavaGlow: true
            },
            crimson_cathedral: {
                gradient: {
                    start: '#1a0a2a',
                    end: '#2a1a3a'
                },
                mountains: {
                    color: '#2a1a4a',
                    count: 15,
                    minHeight: 160,
                    maxHeight: 260,
                    spacing: 280
                },
                buildings: {
                    color: '#3a1a2a',
                    count: 22,
                    minHeight: 140,
                    maxHeight: 240,
                    spacing: 230
                },
                particles: {
                    color: '#ff00ff',
                    count: 120,
                    size: 2.8,
                    speed: 0.8
                },
                fog: {
                    color: 'rgba(100, 0, 100, 0.35)',
                    layers: 6
                },
                cathedral: true,
                stainedGlass: true
            }
        };

        function initGame() {
            document.getElementById('playButton').addEventListener('click', startGame);
            document.getElementById('instructionsButton').addEventListener('click', showInstructions);
            document.getElementById('backButton').addEventListener('click', hideInstructions);
            
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('loadingScreen').style.display = 'none';
            
            setupEventListeners();
            
            gameState.lastFrameTime = performance.now();
        }

        function setupEventListeners() {
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleContextMenu);
            
            document.getElementById('restartButton').addEventListener('click', restartGame);
            document.getElementById('nextLevelButton').addEventListener('click', nextLevel);
            document.getElementById('startLevelButton').addEventListener('click', startLevel);
            
            const weaponOptions = document.querySelectorAll('.weapon-option');
            weaponOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const weaponIndex = parseInt(option.getAttribute('data-weapon'));
                    gameState.player.currentWeapon = weaponIndex;
                    gameState.showWeaponWheel = false;
                    document.getElementById('weaponWheel').style.display = 'none';
                    updateWeaponDisplay();
                    updateUI();
                });
            });
            
            const weaponHudSlots = document.querySelectorAll('.weapon-hud-slot');
            weaponHudSlots.forEach(slot => {
                slot.addEventListener('click', () => {
                    const weaponIndex = parseInt(slot.getAttribute('data-weapon'));
                    gameState.player.currentWeapon = weaponIndex;
                    updateWeaponDisplay();
                    updateUI();
                });
            });
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            gameState.keys[key] = true;
            
            switch(key) {
                case 't':
                    document.getElementById('instructionsMenu').style.display = 
                        document.getElementById('instructionsMenu').style.display === 'block' ? 'none' : 'block';
                    break;
                    
                case 'q':
                    if (!gameState.gameOver && !gameState.levelComplete) {
                        gameState.showWeaponWheel = true;
                        document.getElementById('weaponWheel').style.display = 'block';
                        updateWeaponWheel();
                    }
                    break;
                    
                case 'e':
                    if (gameState.bossDoorActive && !gameState.bossActive && !gameState.bossSpawned) {
                        activateBossDoor();
                    }
                    break;
                    
                case 'f':
                    if (!gameState.gameOver && !gameState.levelComplete && 
                        gameState.player.punchCooldown <= 0) {
                        performPunch();
                    }
                    break;
                    
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                    if (!gameState.gameOver && !gameState.levelComplete) {
                        const weaponIndex = parseInt(key) - 1;
                        if (weaponIndex < gameState.player.weapons.length) {
                            gameState.player.currentWeapon = weaponIndex;
                            updateWeaponDisplay();
                        }
                    }
                    break;
                    
                case 'control':
                    if (!gameState.gameOver && !gameState.levelComplete) {
                        if (gameState.player.isGrounded) {
                            startSlide();
                        } else {
                            performSlam();
                        }
                    }
                    break;
                    
                case 'shift':
                    if (!gameState.gameOver && !gameState.levelComplete && 
                        gameState.player.stamina > 0 && gameState.player.dashCooldown <= 0) {
                        performDash();
                    }
                    break;
                    
                case ' ':
                    if (!gameState.gameOver && !gameState.levelComplete && 
                        gameState.player.stamina > 0 && !gameState.player.isGrounded && 
                        gameState.player.dashCooldown <= 0) {
                        performDash();
                        gameState.player.canAirDash = true;
                    }
                    break;
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            gameState.keys[key] = false;
            
            if (key === 'q') {
                gameState.showWeaponWheel = false;
                document.getElementById('weaponWheel').style.display = 'none';
            }
            
            if (key === 'control') {
                endSlide();
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            gameState.mouse.x = e.clientX - rect.left;
            gameState.mouse.y = e.clientY - rect.top;
            
            if (gameState.showWeaponWheel) {
                updateWeaponWheelSelection(e.clientX, e.clientY);
            }
        }

        function handleMouseDown(e) {
            if (e.button === 0) {
                gameState.mouse.pressed = true;
                if (!gameState.showWeaponWheel && !gameState.gameOver && !gameState.levelComplete) {
                    shoot();
                }
            } else if (e.button === 2) {
                gameState.mouse.rightPressed = true;
                gameState.mouse.rightPressedTime = Date.now();
                gameState.mouse.lastRightClick = Date.now();
                
                if (!gameState.showWeaponWheel && !gameState.gameOver && !gameState.levelComplete) {
                    if (gameState.player.weapons[gameState.player.currentWeapon].name === 'Revolver') {
                        startRevolverCharge();
                    } else if (gameState.player.weapons[gameState.player.currentWeapon].name === 'Rocket Launcher') {
                        toggleRocketFreeze();
                    } else {
                        useWeaponSpecial();
                    }
                }
            }
        }

        function handleMouseUp(e) {
            if (e.button === 0) {
                gameState.mouse.pressed = false;
                
                if (gameState.showWeaponWheel) {
                    selectWeaponFromWheel();
                }
            } else if (e.button === 2) {
                gameState.mouse.rightPressed = false;
                
                if (gameState.player.weapons[gameState.player.currentWeapon].name === 'Revolver') {
                    releaseRevolverCharge();
                }
            }
        }

        function handleContextMenu(e) {
            e.preventDefault();
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            simulateLoading();
        }

        function showInstructions() {
            document.getElementById('instructionsMenu').style.display = 'block';
        }

        function hideInstructions() {
            document.getElementById('instructionsMenu').style.display = 'none';
        }

        function updateWeaponWheelSelection(mouseX, mouseY) {
            const wheel = document.getElementById('weaponWheel');
            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + wheel.offsetWidth / 2;
            const centerY = rect.top + wheel.offsetHeight / 2;
            
            const angle = Math.atan2(mouseY - centerY, mouseX - centerX) + Math.PI;
            const sector = Math.floor((angle) / (Math.PI / 2.5)) % 5;
            
            const weaponOptions = document.querySelectorAll('.weapon-option');
            weaponOptions.forEach(option => {
                option.classList.remove('active');
            });
            
            if (sector >= 0 && sector < weaponOptions.length) {
                weaponOptions[sector].classList.add('active');
            }
        }

        function selectWeaponFromWheel() {
            const activeOption = document.querySelector('.weapon-option.active');
            if (activeOption) {
                const weaponIndex = parseInt(activeOption.getAttribute('data-weapon'));
                gameState.player.currentWeapon = weaponIndex;
                gameState.showWeaponWheel = false;
                document.getElementById('weaponWheel').style.display = 'none';
                updateWeaponDisplay();
                updateUI();
            }
        }

        function updateWeaponWheel() {
            const weaponOptions = document.querySelectorAll('.weapon-option');
            weaponOptions.forEach((option, index) => {
                if (index === gameState.player.currentWeapon) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        function updateWeaponDisplay() {
            const weaponHudSlots = document.querySelectorAll('.weapon-hud-slot');
            weaponHudSlots.forEach((slot, index) => {
                if (index === gameState.player.currentWeapon) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
                
                const weapon = gameState.player.weapons[index];
                let cooldownPercent = 0;
                
                if (weapon.name === 'Nailgun' && weapon.overheatCooldown > 0) {
                    cooldownPercent = weapon.overheatCooldown / weapon.maxOverheatCooldown;
                } else if (weapon.cooldown > 0) {
                    cooldownPercent = weapon.cooldown / weapon.maxCooldown;
                }
                
                let cooldownOverlay = slot.querySelector('.weapon-hud-cooldown');
                if (!cooldownOverlay) {
                    cooldownOverlay = document.createElement('div');
                    cooldownOverlay.className = 'weapon-hud-cooldown';
                    slot.appendChild(cooldownOverlay);
                }
                
                cooldownOverlay.style.height = `${cooldownPercent * 100}%`;
                
                if (weapon.name === 'Nailgun') {
                    let overheatBar = slot.querySelector('.weapon-hud-overheat');
                    if (!overheatBar) {
                        overheatBar = document.createElement('div');
                        overheatBar.className = 'weapon-hud-overheat';
                        slot.appendChild(overheatBar);
                    }
                    const heatPercent = weapon.shotsFired / weapon.maxShots;
                    overheatBar.style.width = `${heatPercent * 100}%`;
                    overheatBar.style.background = heatPercent > 0.7 ? '#ff0000' : '#ff5500';
                }
            });
        }

        function simulateLoading() {
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        showLevelTransition();
                    }, 500);
                }
                document.getElementById('loadingFill').style.width = `${progress}%`;
            }, 100);
        }

        function startRevolverCharge() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            if (weapon.name !== 'Revolver') return;
            
            if (weapon.specialCooldown <= 0 && weapon.canShowCharge) {
                weapon.charging = true;
                weapon.chargeTime = 0;
                weapon.chargeReady = false;
                
                document.getElementById('revolverChargeEffect').style.display = 'block';
                document.getElementById('chargeIndicator').style.display = 'block';
            }
        }

        function updateRevolverCharge(deltaTime) {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            if (!weapon.charging || weapon.name !== 'Revolver') return;
            
            weapon.chargeTime += deltaTime;
            const chargePercent = Math.min(1, weapon.chargeTime / 150);
            
            if (weapon.specialCooldown > 0) {
                weapon.charging = false;
                weapon.chargeTime = 0;
                weapon.chargeReady = false;
                document.getElementById('revolverChargeEffect').style.display = 'none';
                document.getElementById('chargeIndicator').style.display = 'none';
                return;
            }
            
            const chargeEffect = document.getElementById('revolverChargeEffect');
            const chargeSize = 50 + chargePercent * 100;
            chargeEffect.style.width = `${chargeSize}px`;
            chargeEffect.style.height = `${chargeSize}px`;
            chargeEffect.style.background = `radial-gradient(circle, rgba(0, 100, 255, ${0.3 + chargePercent * 0.5}) 0%, rgba(0, 100, 255, 0) 70%)`;
            
            document.getElementById('chargeIndicator').textContent = `CARREGANDO: ${Math.floor(chargePercent * 100)}%`;
            
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 25 + chargePercent * 50;
                const particleX = gameState.player.x + gameState.player.width/2 + Math.cos(angle) * distance;
                const particleY = gameState.player.y + gameState.player.height/2 + Math.sin(angle) * distance;
                
                createParticles(particleX, particleY, 1, '#00aaff', 0.8);
            }
            
            if (chargePercent >= 1 && !weapon.chargeReady) {
                weapon.chargeReady = true;
                document.getElementById('chargeIndicator').textContent = 'PRONTO!';
                document.getElementById('chargeIndicator').style.color = '#ffff00';
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 40;
                    const particleX = gameState.player.x + gameState.player.width/2 + Math.cos(angle) * distance;
                    const particleY = gameState.player.y + gameState.player.height/2 + Math.sin(angle) * distance;
                    
                    createParticles(particleX, particleY, 1, '#ffff00', 0.5);
                }
            }
        }

        function releaseRevolverCharge() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            if (!weapon.charging || weapon.name !== 'Revolver') return;
            
            if (weapon.chargeReady) {
                fireChargedBeam();
            }
            
            weapon.charging = false;
            weapon.chargeTime = 0;
            weapon.chargeReady = false;
            
            document.getElementById('revolverChargeEffect').style.display = 'none';
            document.getElementById('chargeIndicator').style.display = 'none';
            document.getElementById('chargeIndicator').style.color = '#00aaff';
        }

        function fireChargedBeam() {
            const player = gameState.player;
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.specialCooldown > 0) return;
            
            weapon.specialCooldown = weapon.maxSpecialCooldown;
            
            const angle = getAimAngle();
            const beamLength = 600;
            const beamWidth = 15;
            
            const beam = {
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                length: beamLength,
                width: beamWidth,
                angle: angle,
                damage: 120 * player.bloodRageMultiplier,
                color: '#0066ff',
                life: 10,
                fromEnemy: false,
                isSpecial: true,
                weaponType: 'Revolver',
                beam: true,
                pierce: true
            };
            
            gameState.bullets.push(beam);
            
            createBeamParticles(beam.x, beam.y, angle, beamLength, beamWidth);
            
            const endX = beam.x + Math.cos(angle) * beamLength;
            const endY = beam.y + Math.sin(angle) * beamLength;
            
            gameState.enemies.forEach(enemy => {
                if (enemy.type === 'boss') return;
                
                const enemyCenterX = enemy.x + enemy.width/2;
                const enemyCenterY = enemy.y + enemy.height/2;
                
                const dist = pointToLineDistance(enemyCenterX, enemyCenterY, beam.x, beam.y, endX, endY);
                if (dist < (beamWidth/2 + enemy.width/2)) {
                    enemy.health -= beam.damage;
                    createParticles(enemyCenterX, enemyCenterY, 8, '#00aaff', 1.5);
                    
                    if (enemy.health <= 0) {
                        enemyKilled(enemy);
                        gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                    }
                }
            });
            
            if (gameState.currentBoss) {
                const boss = gameState.currentBoss;
                const bossCenterX = boss.x + boss.width/2;
                const bossCenterY = boss.y + boss.height/2;
                
                const dist = pointToLineDistance(bossCenterX, bossCenterY, beam.x, beam.y, endX, endY);
                if (dist < (beamWidth/2 + boss.width/2)) {
                    boss.health -= beam.damage;
                    createParticles(bossCenterX, bossCenterY, 12, '#00aaff', 2);
                    
                    if (boss.health <= 0) {
                        bossKilled(boss);
                    }
                }
            }
            
            gameState.camera.shake = 25;
            gameState.camera.shakeIntensity = 12;
            
            addStylePoints(20, 'CHARGED BEAM');
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function createBeamParticles(x, y, angle, length, width) {
            const segments = Math.floor(length / 20);
            for (let i = 0; i < segments; i++) {
                const segmentX = x + Math.cos(angle) * (i * 20);
                const segmentY = y + Math.sin(angle) * (i * 20);
                
                for (let j = 0; j < 3; j++) {
                    const offset = (Math.random() - 0.5) * width;
                    const offsetAngle = angle + Math.PI/2;
                    const particleX = segmentX + Math.cos(offsetAngle) * offset;
                    const particleY = segmentY + Math.sin(offsetAngle) * offset;
                    
                    createParticles(particleX, particleY, 1, '#00aaff', 1.2);
                }
                
                if (Math.random() < 0.3) {
                    createParticles(segmentX, segmentY, 1, '#ffffff', 0.8);
                }
            }
        }

        function performPunch() {
            const player = gameState.player;
            player.punchCooldown = player.maxPunchCooldown;
            player.lastPunchHit = Date.now();
            
            const angle = getAimAngle();
            const punchX = player.x + player.width/2 + Math.cos(angle) * 40;
            const punchY = player.y + player.height/2 + Math.sin(angle) * 40;
            
            createParticles(punchX, punchY, 12, '#ffffff', 1.2);
            
            for (let i = 0; i < 8; i++) {
                const sparkAngle = angle + (Math.random() - 0.5) * 0.5;
                const sparkDist = player.punchRange * (0.3 + Math.random() * 0.7);
                createParticles(
                    player.x + player.width/2 + Math.cos(sparkAngle) * sparkDist,
                    player.y + player.height/2 + Math.sin(sparkAngle) * sparkDist,
                    1,
                    '#ffff00',
                    0.6
                );
            }
            
            let hitEnemy = false;
            gameState.enemies.forEach(enemy => {
                const dx = enemy.x + enemy.width/2 - punchX;
                const dy = enemy.y + enemy.height/2 - punchY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < player.punchRange) {
                    const damage = player.punchDamage * player.bloodRageMultiplier;
                    enemy.health -= damage;
                    hitEnemy = true;
                    
                    const hitAngle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(hitAngle) * 30;
                    enemy.y += Math.sin(hitAngle) * 25;
                    
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 15, '#ff0000', 1.2);
                    
                    addStylePoints(10, 'PUNCH');
                    
                    if (enemy.health <= 0) {
                        enemyKilled(enemy);
                        gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                    }
                }
            });
            
            if (gameState.currentBoss) {
                const boss = gameState.currentBoss;
                const dx = boss.x + boss.width/2 - punchX;
                const dy = boss.y + boss.height/2 - punchY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < player.punchRange) {
                    const damage = player.punchDamage * player.bloodRageMultiplier * 0.5;
                    boss.health -= damage;
                    hitEnemy = true;
                    
                    createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 15, '#ff0000', 1.5);
                    addStylePoints(15, 'BOSS PUNCH');
                    
                    if (boss.health <= 0) {
                        bossKilled(boss);
                    }
                }
            }
            
            if (hitEnemy) {
                player.health = Math.min(player.maxHealth, player.health + player.punchHealAmount);
                createTextParticles(player.x + player.width/2, player.y, `+${player.punchHealAmount} HEALTH`, '#00ff00');
                updateUI();
            }
            
            updateUI();
        }

        function startSlide() {
            const player = gameState.player;
            if (player.sliding) return;
            
            player.sliding = true;
            player.slideTime = 30;
            player.height = 40;
            player.y += 40;
            player.slideDirection = gameState.keys['a'] ? -1 : gameState.keys['d'] ? 1 : 0;
            
            createParticles(player.x + player.width/2, player.y + player.height, 12, '#666666', 0.8);
            document.getElementById('slideIndicator').style.display = 'flex';
        }

        function endSlide() {
            const player = gameState.player;
            if (!player.sliding) return;
            
            player.sliding = false;
            player.height = 80;
            player.y -= 40;
            
            document.getElementById('slideIndicator').style.display = 'none';
        }

        function performSlam() {
            const player = gameState.player;
            
            player.velocityY = Math.min(player.velocityY + 20, 30);
            
            createParticles(player.x + player.width/2, player.y + player.height/2, 15, '#00aaff', 1);
            addStylePoints(5, 'AIRSLAM');
        }

        function performDash() {
            const player = gameState.player;
            
            if (player.stamina <= 0 || player.dashCooldown > 0) return;
            
            player.isDashing = true;
            player.dashDuration = 12;
            player.stamina--;
            player.dashCooldown = 30;
            player.staminaRegenTimer = 180;
            
            let dashX = 0;
            let dashY = 0;
            
            if (gameState.keys['a']) dashX = -1;
            if (gameState.keys['d']) dashX = 1;
            if (gameState.keys['w']) dashY = -1;
            if (gameState.keys['s']) dashY = 1;
            
            if (dashX === 0 && dashY === 0) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = gameState.mouse.x;
                const playerScreenX = player.x - gameState.camera.x + player.width / 2;
                dashX = mouseX > playerScreenX ? 1 : -1;
            }
            
            const length = Math.sqrt(dashX * dashX + dashY * dashY);
            dashX /= length;
            dashY /= length;
            
            player.velocityX = dashX * 30;
            player.velocityY = dashY * 25;
            
            createParticles(player.x + player.width/2, player.y + player.height/2, 15, '#00aaff', 1.2);
            addStylePoints(3, 'DASH');
            
            updateStaminaUI();
            
            if (player.stamina === 0) {
                document.getElementById('staminaRegenIndicator').style.display = 'block';
                document.getElementById('staminaRegenIndicator').textContent = 'STAMINA REGENERANDO...';
                setTimeout(() => {
                    document.getElementById('staminaRegenIndicator').style.display = 'none';
                }, 1000);
            }
        }

        function updateStaminaUI() {
            const player = gameState.player;
            const segments = [
                document.getElementById('staminaSegment1'),
                document.getElementById('staminaSegment2'),
                document.getElementById('staminaSegment3')
            ];
            
            segments.forEach((segment, index) => {
                if (index < player.stamina) {
                    segment.classList.remove('empty');
                    segment.querySelector('.stamina-fill').style.width = '100%';
                } else {
                    segment.classList.add('empty');
                    segment.querySelector('.stamina-fill').style.width = '0%';
                }
            });
            
            document.getElementById('staminaLabel').textContent = `DASH STAMINA: ${player.stamina}/3`;
        }

        function toggleRocketFreeze() {
            const rocketLauncher = gameState.player.weapons[4];
    
    if (rocketLauncher.freezeCooldown > 0) return;
    
    rocketLauncher.frozenRockets = !rocketLauncher.frozenRockets;
    rocketLauncher.freezeActive = rocketLauncher.frozenRockets;
    
    if (rocketLauncher.frozenRockets) {
        rocketLauncher.freezeDuration = rocketLauncher.maxFreezeDuration;
        
        // Mostrar efeito visual
        document.getElementById('rocketFreezeAura').style.display = 'block';
        
        // *** CONGELAR TODOS OS PROJ√âTEIS EXISTENTES ***
        rocketLauncher.activeRockets.forEach(rocket => {
            rocket.speed = 0; // Velocidade ZERO
            rocket.frozen = true;
            
            // Efeito de congelamento
            for (let i = 0; i < 12; i++) {
                createParticles(rocket.x, rocket.y, 1, '#00aaff', 1.5);
            }
        });
        
        // Efeito no jogador
        for (let i = 0; i < 25; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 60;
            createParticles(
                gameState.player.x + gameState.player.width/2 + Math.cos(angle) * distance,
                gameState.player.y + gameState.player.height/2 + Math.sin(angle) * distance,
                1,
                '#00aaff',
                2
            );
        }
        
        // Somar pontos de estilo
        addStylePoints(0, 'ROCKET FREEZE ACTIVATED');
        
        // Efeito de tela
        gameState.camera.shake = 25;
        gameState.camera.shakeIntensity = 12;
        
    } else {
        rocketLauncher.freezeDuration = 0;
        document.getElementById('rocketFreezeAura').style.display = 'none';
        
        // *** DESCONGELAR TODOS OS PROJ√âTEIS ***
        rocketLauncher.activeRockets.forEach(rocket => {
            rocket.speed = 10; // Velocidade normal
            rocket.frozen = false;
            
            // Efeito de descongelamento
            for (let i = 0; i < 8; i++) {
                createParticles(rocket.x, rocket.y, 1, '#ff8800', 1.2);
            }
        });
        
        // Efeito no jogador
        for (let i = 0; i < 15; i++) {
            createParticles(
                gameState.player.x + gameState.player.width/2,
                gameState.player.y + gameState.player.height/2,
                1,
                '#ff8800',
                1.5
            );
        }
        
        addStylePoints(5, 'ROCKET FREEZE DEACTIVATED');
        rocketLauncher.freezeCooldown = 30;
    }
        }
        function showLevelTransition() {
            const level = levels[gameState.currentLevel - 1];
            document.getElementById('levelTitle').textContent = `N√çVEL ${gameState.currentLevel}: ${level.name}`;
            document.getElementById('levelDescription').textContent = level.description;
            document.getElementById('levelEnemies').textContent = level.enemyCount;
            document.getElementById('levelSecrets').textContent = level.secretCount;
            document.getElementById('levelDifficulty').textContent = level.difficulty;
            
            document.getElementById('levelTransition').style.display = 'flex';
        }

        function startLevel() {
            document.getElementById('levelTransition').style.display = 'none';
            gameState.levelStartTime = Date.now();
            loadLevel(gameState.currentLevel - 1);
        }

        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            
            gameState.player.x = 100;
            gameState.player.y = 300;
            gameState.player.velocityX = 0;
            gameState.player.velocityY = 0;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.stamina = gameState.player.maxStamina;
            gameState.player.staminaCooldown = 0;
            gameState.player.staminaRegenTimer = 0;
            gameState.player.isGrounded = false;
            gameState.player.isDashing = false;
            gameState.player.canAirDash = true;
            gameState.player.sliding = false;
            gameState.player.wallRunning = false;
            gameState.player.bloodRageMultiplier = 1;
            gameState.player.coins = 0;
            gameState.player.punchCooldown = 0;
            gameState.player.lastTrapDamage = 0;
            gameState.player.lastEnemyCollisionDamage = 0;
            
            gameState.player.weapons.forEach(weapon => {
                weapon.cooldown = 0;
                weapon.specialCooldown = 0;
                weapon.charging = false;
                weapon.chargeTime = 0;
                weapon.chargeReady = false;
                weapon.canShowCharge = true;
                if (weapon.name === 'Nailgun') {
                    weapon.shotsFired = 0;
                    weapon.overheatCooldown = 0;
                }
                if (weapon.name === 'Rocket Launcher') {
                    weapon.activeRockets = [];
                    weapon.frozenRockets = false;
                    weapon.freezeTime = 0;
                    weapon.freezeActive = false;
                    weapon.freezeDuration = 0;
                    weapon.freezeCooldown = 0;
                }
            });
            
            gameState.player.abilities.timeSlow.active = false;
            gameState.player.abilities.timeSlow.duration = 0;
            gameState.player.abilities.timeSlow.cooldown = 0;
            
            gameState.player.abilities.bloodRage.active = false;
            gameState.player.abilities.bloodRage.duration = 0;
            gameState.player.abilities.bloodRage.cooldown = 0;
            
            gameState.timeScale = 1;
            
            gameState.magnetNails = [];
            gameState.orbitingNails = [];
            gameState.bossDoors = [];
            gameState.currentBoss = null;
            gameState.bossActive = false;
            gameState.bossSpawned = false;
            gameState.bossDoorActive = false;
            gameState.bossBarriers = [];
            gameState.bossDashTrail = [];
            gameState.bossChargeTime = 0;
            gameState.bossChargingDash = false;
            gameState.bossLastDash = 0;
            
            gameState.platforms = level.platforms.map(platform => ({ 
                ...platform,
                moveDirection: 1
            }));
            
            gameState.obstacles = level.obstacles;
            
            gameState.decorations = level.decorations;
            
            gameState.pickups = level.pickups.map(pickup => ({ ...pickup }));
            
            if (level.bossDoor) {
                gameState.bossDoors.push({ ...level.bossDoor });
            }
            
            gameState.bossBarriers = gameState.platforms.filter(p => p.type === 'boss_barrier');
            
            gameState.enemies = [];
            level.enemySpawns.forEach(spawn => {
                const enemyType = enemyTypes[spawn.type];
                gameState.enemies.push({
                    ...enemyType,
                    type: spawn.type,
                    x: spawn.x,
                    y: spawn.y - enemyType.height,
                    originalY: spawn.y - enemyType.height,
                    health: enemyType.health,
                    maxHealth: enemyType.health,
                    lastAttack: 0,
                    target: null,
                    state: 'patrol',
                    moveDirection: Math.random() > 0.5 ? 1 : -1,
                    specialAttackCooldown: 0,
                    patrolStartX: spawn.x - enemyType.patrolRange/2,
                    patrolEndX: spawn.x + enemyType.patrolRange/2,
                    lastHitTime: 0
                });
            });
            
            gameState.bullets = [];
            gameState.particles = [];
            gameState.shockwaves = [];
            
            gameState.score = 0;
            gameState.stylePoints = 0;
            gameState.styleRank = 'D';
            gameState.styleMultiplier = 1;
            gameState.lastKillTime = 0;
            gameState.killCount = 0;
            gameState.killCombo = 0;
            gameState.maxCombo = 0;
            gameState.styleEvents = [];
            
            gameState.gameOver = false;
            gameState.levelComplete = false;
            
            gameState.camera.shake = 0;
            gameState.camera.shakeIntensity = 0;
            
            createBackground(level.background);
            
            document.getElementById('comboCounter').style.display = 'none';
            document.getElementById('stylePointsContainer').style.display = 'none';
            document.getElementById('doorInteraction').style.display = 'none';
            document.getElementById('enemyHealthContainer').style.display = 'none';
            document.getElementById('revolverChargeEffect').style.display = 'none';
            document.getElementById('chargeIndicator').style.display = 'none';
            document.getElementById('staminaRegenIndicator').style.display = 'none';
            document.getElementById('rocketFreezeAura').style.display = 'none';
            document.getElementById('bossDashAura').style.display = 'none';
            document.getElementById('bossDashTrail').style.display = 'none';
            document.getElementById('bossChargeEffect').style.display = 'none';
            
            updateUI();
            updateWeaponDisplay();
            updateStaminaUI();
            
            if (!gameState.gameLoopRunning) {
                gameState.gameLoopRunning = true;
                gameLoop();
            }
        }

        function createBackground(backgroundType) {
            gameState.backgrounds = [];
            gameState.backgroundParticles = [];
            
            const bgConfig = backgroundTypes[backgroundType];
            
            for (let i = 0; i < bgConfig.mountains.count; i++) {
                gameState.backgrounds.push({
                    type: 'mountain',
                    x: i * bgConfig.mountains.spacing,
                    y: canvas.height - 100,
                    width: 300,
                    height: bgConfig.mountains.minHeight + Math.random() * (bgConfig.mountains.maxHeight - bgConfig.mountains.minHeight),
                    color: bgConfig.mountains.color,
                    layer: 0.1
                });
            }
            
            for (let i = 0; i < bgConfig.buildings.count; i++) {
                gameState.backgrounds.push({
                    type: 'building',
                    x: i * bgConfig.buildings.spacing,
                    y: canvas.height - 150,
                    width: 60 + Math.random() * 80,
                    height: bgConfig.buildings.minHeight + Math.random() * (bgConfig.buildings.maxHeight - bgConfig.buildings.minHeight),
                    color: bgConfig.buildings.color,
                    layer: 0.2,
                    windows: []
                });
            }
            
            for (let i = 0; i < bgConfig.particles.count; i++) {
                gameState.backgroundParticles.push({
                    x: Math.random() * 10000,
                    y: Math.random() * canvas.height,
                    size: bgConfig.particles.size,
                    color: bgConfig.particles.color,
                    speed: bgConfig.particles.speed * (0.5 + Math.random() * 0.5),
                    layer: 0.3 + Math.random() * 0.4
                });
            }
            
            for (let i = 0; i < bgConfig.fog.layers; i++) {
                gameState.backgrounds.push({
                    type: 'fog',
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                    color: bgConfig.fog.color,
                    layer: 0.5 + i * 0.1,
                    speed: 0.1 + i * 0.05
                });
            }
        }

        function gameLoop() {
            const currentTime = performance.now();
            const deltaTime = currentTime - gameState.lastFrameTime;
            gameState.fps = Math.round(1000 / deltaTime);
            gameState.lastFrameTime = currentTime;
            
            const scaledDeltaTime = gameState.timeScale;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateCamera();
            
            drawBackground();
            
            if (!gameState.gameOver && !gameState.levelComplete && 
                document.getElementById('levelTransition').style.display === 'none' &&
                !gameState.showWeaponWheel) {
                
                updatePlayer(scaledDeltaTime);
                updateEnemies(scaledDeltaTime);
                updateBullets(scaledDeltaTime);
                updateParticles(scaledDeltaTime);
                updateMagnetNails(scaledDeltaTime);
                updateOrbitingNails(scaledDeltaTime);
                updateRockets(scaledDeltaTime);
                updatePickups(scaledDeltaTime);
                updateStyle(scaledDeltaTime);
                updateWeaponCooldowns(scaledDeltaTime);
                updateShockwaves(scaledDeltaTime);
                updateStyleEvents(scaledDeltaTime);
                updateBoss(scaledDeltaTime);
                updateRevolverCharge(scaledDeltaTime);
                updateStaminaRegen(scaledDeltaTime);
                updateEnemyHitCooldowns(scaledDeltaTime);
                updateRocketFreezeAura(scaledDeltaTime);
                updateBossDash(scaledDeltaTime);
                
                checkCollisions();
                checkBossDoorInteraction();
                checkLevelCompletion();
                checkMapFall();
                
                drawPlatforms();
                drawObstacles();
                drawDecorations();
                drawPickups();
                drawBossDoor();
                drawPlayer();
                drawEnemies();
                drawBoss();
                drawBullets();
                drawParticles();
                drawShockwaves();
                drawGoal();
            }
            
            drawUI();
            
            if (!gameState.gameOver && !gameState.levelComplete) {
                gameState.levelTime = Date.now() - gameState.levelStartTime;
            }
            
            document.getElementById('fpsCounter').textContent = `FPS: ${gameState.fps}`;
            
            requestAnimationFrame(gameLoop);
        }

        function updateCamera() {
            gameState.camera.x = gameState.player.x - canvas.width / 2;
            gameState.camera.y = gameState.player.y - canvas.height / 2;
            
            if (gameState.camera.shake > 0) {
                gameState.camera.x += (Math.random() - 0.5) * gameState.camera.shakeIntensity;
                gameState.camera.y += (Math.random() - 0.5) * gameState.camera.shakeIntensity;
                gameState.camera.shake--;
            }
            
            gameState.camera.x = gameState.camera.x * 0.8 + (gameState.player.x - canvas.width / 2) * 0.2;
            gameState.camera.y = gameState.camera.y * 0.8 + (gameState.player.y - canvas.height / 2) * 0.2;
        }

        function updatePlayer(deltaTime) {
            const player = gameState.player;
            
            if (!player.isGrounded && !player.wallRunning) {
                player.velocityY += 0.7 * deltaTime;
            } else {
                player.canAirDash = true;
            }
            
            if (player.sliding) {
                player.slideTime--;
                if (player.slideTime <= 0 || !player.isGrounded) {
                    endSlide();
                } else {
                    if (player.slideDirection !== 0) {
                        player.velocityX = player.slideDirection * player.speed * 1.5 * deltaTime;
                    }
                    if (player.slideTime % 5 === 0) {
                        createParticles(player.x + player.width/2, player.y + player.height, 4, '#666666', 0.6);
                    }
                }
            } else {
                if (gameState.keys['a']) {
                    player.velocityX = -player.speed * deltaTime;
                } else if (gameState.keys['d']) {
                    player.velocityX = player.speed * deltaTime;
                } else {
                    player.velocityX *= 0.85 * deltaTime;
                }
            }
            
            if (gameState.keys['w'] && player.isGrounded) {
                player.velocityY = -player.jumpPower;
                player.isGrounded = false;
                createParticles(player.x + player.width/2, player.y + player.height, 6, '#ffffff', 0.8);
            }
            
            player.wallRunning = false;
            if (!player.isGrounded && (gameState.keys['a'] || gameState.keys['d'])) {
                let wallSide = 0;
                
                if (gameState.keys['a']) {
                    gameState.platforms.forEach(platform => {
                        if (platform.type === 'wall' && platform.topSolid &&
                            player.x <= platform.x + platform.width &&
                            player.x >= platform.x + platform.width - 15 &&
                            player.y + player.height > platform.y &&
                            player.y < platform.y + platform.height) {
                            
                            wallSide = -1;
                            player.wallRunning = true;
                            player.wallRunSide = -1;
                            player.wallRunTime++;
                            
                            player.velocityY = -2.5 * deltaTime;
                            player.velocityX = 0;
                            player.y = Math.max(player.y, platform.y - player.height);
                            
                            if (player.wallRunTime % 4 === 0) {
                                createParticles(player.x, player.y + player.height/2, 3, '#00aaff', 0.6);
                            }
                        }
                    });
                }
                
                if (gameState.keys['d'] && !player.wallRunning) {
                    gameState.platforms.forEach(platform => {
                        if (platform.type === 'wall' && platform.topSolid &&
                            player.x + player.width >= platform.x &&
                            player.x + player.width <= platform.x + 15 &&
                            player.y + player.height > platform.y &&
                            player.y < platform.y + platform.height) {
                            
                            wallSide = 1;
                            player.wallRunning = true;
                            player.wallRunSide = 1;
                            player.wallRunTime++;
                            
                            player.velocityY = -2.5 * deltaTime;
                            player.velocityX = 0;
                            player.y = Math.max(player.y, platform.y - player.height);
                            
                            if (player.wallRunTime % 4 === 0) {
                                createParticles(player.x + player.width, player.y + player.height/2, 3, '#00aaff', 0.6);
                            }
                        }
                    });
                }
                
                if (player.wallRunning && gameState.keys[' ']) {
                    player.velocityY = -player.jumpPower * 0.9;
                    player.velocityX = player.wallRunSide * player.speed * 1.8;
                    player.wallRunning = false;
                    player.canAirDash = true;
                    
                    createParticles(
                        player.x + (player.wallRunSide === -1 ? 0 : player.width), 
                        player.y + player.height/2, 
                        8, '#00aaff', 0.8
                    );
                    
                    addStylePoints(5, 'WALLJUMP');
                }
            } else {
                player.wallRunTime = 0;
            }
            
            if (player.isDashing) {
                player.dashDuration--;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                }
            }
            
            if (player.dashCooldown > 0) {
                player.dashCooldown -= deltaTime;
            }
            
            if (player.punchCooldown > 0) {
                player.punchCooldown -= deltaTime;
            }
            
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            player.isGrounded = false;
            
            gameState.platforms.forEach(platform => {
                if (!platform.solid) return;
                
                if (platform.type === 'moving') {
                    platform.x += platform.speed * deltaTime * platform.moveDirection;
                    
                    if (platform.x <= platform.startX || platform.x >= platform.endX) {
                        platform.moveDirection = -platform.moveDirection;
                    }
                }
                
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + 20 &&
                    player.velocityY > 0) {
                    
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.isGrounded = true;
                    
                    if (platform.type === 'moving') {
                        player.x += platform.speed * deltaTime * platform.moveDirection;
                    }
                }
                
                if (platform.type === 'wall' && platform.solid) {
                    if (player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        player.y < platform.y + platform.height &&
                        player.y + player.height > platform.y) {
                        
                        if (player.velocityX > 0 && player.x + player.width > platform.x && player.x < platform.x) {
                            player.x = platform.x - player.width;
                            player.velocityX = 0;
                        } else if (player.velocityX < 0 && player.x < platform.x + platform.width && player.x + player.width > platform.x + platform.width) {
                            player.x = platform.x + platform.width;
                            player.velocityX = 0;
                        }
                    }
                }
            });
            
            const now = Date.now();
            gameState.obstacles.forEach(obstacle => {
                if (player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y) {
                    
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const obstacleCenterX = obstacle.x + obstacle.width / 2;
                    const obstacleCenterY = obstacle.y + obstacle.height / 2;
                    
                    const dx = playerCenterX - obstacleCenterX;
                    const dy = playerCenterY - obstacleCenterY;
                    
                    const overlapX = player.width / 2 + obstacle.width / 2 - Math.abs(dx);
                    const overlapY = player.height / 2 + obstacle.height / 2 - Math.abs(dy);
                    
                    if (overlapX < overlapY) {
                        if (dx > 0) {
                            player.x = obstacle.x + obstacle.width;
                        } else {
                            player.x = obstacle.x - player.width;
                        }
                        player.velocityX = 0;
                    } else {
                        if (dy > 0) {
                            player.y = obstacle.y + obstacle.height;
                            player.velocityY = 0;
                        } else {
                            player.y = obstacle.y - player.height;
                            player.velocityY = 0;
                            player.isGrounded = true;
                        }
                    }
                    
                    if ((obstacle.type === 'spike' || obstacle.type === 'lava_pit' || 
                         obstacle.type === 'forge_fire' || obstacle.type === 'cathedral_trap') &&
                        now - player.lastTrapDamage > player.trapDamageCooldown) {
                        
                        let damage = 0;
                        if (obstacle.type === 'spike') damage = 8;
                        else damage = 5;
                        
                        player.health -= damage;
                        player.lastTrapDamage = now;
                        
                        createParticles(player.x + player.width/2, player.y + player.height/2, 
                                       obstacle.type === 'spike' ? 8 : 6, 
                                       obstacle.type === 'spike' ? '#ff0000' : '#ff5500', 
                                       obstacle.type === 'spike' ? 1 : 0.8);
                        gameState.camera.shake = obstacle.type === 'spike' ? 15 : 8;
                        gameState.camera.shakeIntensity = obstacle.type === 'spike' ? 8 : 4;
                        
                        showDamageIndicator();
                        gameState.stylePoints = Math.max(0, gameState.stylePoints - (obstacle.type === 'spike' ? 15 : 10));
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
            
            updateUI();
        }

        function updateRocketFreezeAura(deltaTime) {
            const rocketLauncher = gameState.player.weapons[4];
            const aura = document.getElementById('rocketFreezeAura');
            
            if (rocketLauncher.freezeActive) {
                const player = gameState.player;
                aura.style.left = `${player.x - gameState.camera.x + player.width/2}px`;
                aura.style.top = `${player.y - gameState.camera.y + player.height/2}px`;
                
                rocketLauncher.freezeDuration -= deltaTime;
                if (rocketLauncher.freezeDuration <= 0) {
                    rocketLauncher.frozenRockets = false;
                    rocketLauncher.freezeActive = false;
                    aura.style.display = 'none';
                    
                    rocketLauncher.activeRockets.forEach(rocket => {
                        rocket.speed = 10;
                    });
                    
                    rocketLauncher.freezeCooldown = 180;
                }
            }
            
            if (rocketLauncher.freezeCooldown > 0) {
                rocketLauncher.freezeCooldown -= deltaTime;
            }
        }

        function updateStaminaRegen(deltaTime) {
            const player = gameState.player;
            
            if (player.stamina < player.maxStamina) {
                if (player.staminaRegenTimer > 0) {
                    player.staminaRegenTimer -= deltaTime;
                } else {
                    player.stamina = Math.min(player.maxStamina, player.stamina + 1);
                    player.staminaRegenTimer = 180;
                    updateStaminaUI();
                    
                    if (player.stamina === 1) {
                        createTextParticles(player.x + player.width/2, player.y, 'STAMINA READY', '#00aaff');
                    }
                }
            }
        }

        function checkMapFall() {
            const player = gameState.player;
            
            if (player.y > gameState.mapBottomLimit) {
                createParticles(player.x + player.width/2, player.y + player.height/2, 15, '#ff0000', 1.2);
                
                if (player.health > 70) {
                    player.health = 50;
                } else if (player.health >= 30) {
                    player.health = 10;
                } else {
                    player.health = Math.max(1, player.health - 10);
                }
                
                showDamageIndicator();
                
                player.x = 100;
                player.y = 300;
                player.velocityX = 0;
                player.velocityY = 0;
                
                gameState.camera.shake = 25;
                gameState.camera.shakeIntensity = 12;
                
                updateUI();
                addStylePoints(-20, 'MAPFALL');
            }
        }

        function updateWeaponCooldowns(deltaTime) {
            const player = gameState.player;
            
            player.weapons.forEach(weapon => {
                if (weapon.cooldown > 0) {
                    weapon.cooldown -= deltaTime;
                }
                
                if (weapon.specialCooldown > 0) {
                    weapon.specialCooldown -= deltaTime;
                    if (weapon.name === 'Revolver') {
                        weapon.canShowCharge = weapon.specialCooldown <= 0;
                    }
                }
                
                if (weapon.name === 'Nailgun') {
                    if (weapon.overheatCooldown > 0) {
                        weapon.overheatCooldown -= deltaTime;
                    } else if (weapon.shotsFired > 0) {
                        weapon.shotsFired = Math.max(0, weapon.shotsFired - 0.1 * deltaTime);
                    }
                }
            });
            
            updateWeaponDisplay();
        }

        function updateRockets(deltaTime) {
            const rocketLauncher = gameState.player.weapons[4];
            
            for (let i = rocketLauncher.activeRockets.length - 1; i >= 0; i--) {
                const rocket = rocketLauncher.activeRockets[i];
                
                if (rocketLauncher.frozenRockets && rocketLauncher.freezeActive) {
                    rocket.life--;
                    
                    if (Math.random() < 0.3) {
                        createParticles(rocket.x, rocket.y, 1, '#00aaff', 0.8);
                    }
                    
                    if (rocket.life <= 0) {
                        createExplosion(rocket.x, rocket.y, rocket.explosionRadius, rocket.damage);
                        rocketLauncher.activeRockets.splice(i, 1);
                    }
                } else {
                    rocket.x += rocket.dx * rocket.speed * deltaTime;
                    rocket.y += rocket.dy * rocket.speed * deltaTime;
                    
                    if (Math.random() < 0.5) {
                        createParticles(rocket.x, rocket.y, 1, '#888888', 0.6);
                    }
                    
                    rocket.life--;
                    if (rocket.life <= 0) {
                        createExplosion(rocket.x, rocket.y, rocket.explosionRadius, rocket.damage);
                        rocketLauncher.activeRockets.splice(i, 1);
                    }
                }
            }
        }

        function updateMagnetNails(deltaTime) {
            for (let i = gameState.magnetNails.length - 1; i >= 0; i--) {
                const magnetNail = gameState.magnetNails[i];
                magnetNail.life--;
                
                if (magnetNail.life <= 0) {
                    gameState.magnetNails.splice(i, 1);
                }
            }
        }

        function updateOrbitingNails(deltaTime) {
            gameState.magnetNails.forEach(magnetNail => {
                gameState.bullets.forEach(bullet => {
                    if (bullet.weaponType === 'Nailgun' && !bullet.isSpecial) {
                        const dx = magnetNail.x - bullet.x;
                        const dy = magnetNail.y - bullet.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < 200 && !bullet.orbiting && !bullet.movingToMagnet) {
                            bullet.movingToMagnet = {
                                magnetNail: magnetNail,
                                startX: bullet.x,
                                startY: bullet.y,
                                progress: 0,
                                maxProgress: 30,
                                curve: Math.random() * 0.5 - 0.25
                            };
                            bullet.noCollision = true;
                        }
                    }
                });
            });
            
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                if (bullet.movingToMagnet) {
                    const move = bullet.movingToMagnet;
                    move.progress++;
                    
                    const t = move.progress / move.maxProgress;
                    const curve = Math.sin(t * Math.PI) * move.curve;
                    
                    bullet.x = move.startX + (move.magnetNail.x - move.startX) * t + curve * 50;
                    bullet.y = move.startY + (move.magnetNail.y - move.startY) * t + curve * 30;
                    
                    if (move.progress >= move.maxProgress) {
                        bullet.orbiting = {
                            magnetNail: move.magnetNail,
                            angle: Math.atan2(bullet.y - move.magnetNail.y, bullet.x - move.magnetNail.x),
                            radius: 60 + Math.random() * 30,
                            speed: 0.05 + Math.random() * 0.02,
                            life: 300
                        };
                        bullet.movingToMagnet = null;
                    }
                }
                
                if (bullet.orbiting) {
                    bullet.orbiting.angle += bullet.orbiting.speed * deltaTime;
                    bullet.orbiting.life--;
                    
                    bullet.x = bullet.orbiting.magnetNail.x + Math.cos(bullet.orbiting.angle) * bullet.orbiting.radius;
                    bullet.y = bullet.orbiting.magnetNail.y + Math.sin(bullet.orbiting.angle) * bullet.orbiting.radius;
                    
                    bullet.dx = -Math.sin(bullet.orbiting.angle);
                    bullet.dy = Math.cos(bullet.orbiting.angle);
                    
                    let hitEnemy = false;
                    gameState.enemies.forEach(enemy => {
                        const dx = enemy.x + enemy.width/2 - bullet.x;
                        const dy = enemy.y + enemy.height/2 - bullet.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < (bullet.radius + enemy.width/2)) {
                            const damage = 15 * gameState.player.bloodRageMultiplier;
                            enemy.health -= damage;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 4, '#00aaff', 0.8);
                            hitEnemy = true;
                            
                            if (enemy.health <= 0) {
                                enemyKilled(enemy);
                                gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                            }
                        }
                    });
                    
                    if (gameState.currentBoss) {
                        const boss = gameState.currentBoss;
                        const dx = boss.x + boss.width/2 - bullet.x;
                        const dy = boss.y + boss.height/2 - bullet.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < (bullet.radius + boss.width/2)) {
                            const damage = 10 * gameState.player.bloodRageMultiplier;
                            boss.health -= damage;
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 6, '#00aaff', 1);
                            hitEnemy = true;
                            
                            if (boss.health <= 0) {
                                bossKilled(boss);
                            }
                        }
                    }
                    
                    if (hitEnemy) {
                        gameState.bullets.splice(i, 1);
                        continue;
                    }
                    
                    if (Math.random() < 0.4) {
                        createParticles(bullet.x, bullet.y, 1, bullet.color, 0.6);
                    }
                    
                    if (bullet.orbiting.life <= 0) {
                        gameState.bullets.splice(i, 1);
                    }
                }
            }
        }

        function updateShockwaves(deltaTime) {
            for (let i = gameState.shockwaves.length - 1; i >= 0; i--) {
                const shockwave = gameState.shockwaves[i];
                shockwave.radius += shockwave.speed * deltaTime;
                shockwave.life--;
                
                if (shockwave.life <= 0) {
                    gameState.shockwaves.splice(i, 1);
                }
            }
        }

        function updateStyleEvents(deltaTime) {
            for (let i = gameState.styleEvents.length - 1; i >= 0; i--) {
                const event = gameState.styleEvents[i];
                event.life--;
                
                if (event.life <= 0) {
                    gameState.styleEvents.splice(i, 1);
                }
            }
            
            if (gameState.styleEvents.length > 0) {
                const container = document.getElementById('stylePointsContainer');
                container.style.display = 'block';
                container.innerHTML = '';
                
                const eventsToShow = gameState.styleEvents.slice(-5);
                eventsToShow.forEach(event => {
                    const div = document.createElement('div');
                    div.className = 'stylePoint';
                    div.innerHTML = `
                        <span class="stylePointType">${event.type}</span>
                        <span class="stylePointValue">+${event.value}</span>
                    `;
                    container.appendChild(div);
                });
            } else {
                document.getElementById('stylePointsContainer').style.display = 'none';
            }
        }

        function updateEnemies(deltaTime) {
            gameState.enemies.forEach(enemy => {
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < enemy.attackRange) {
                    if (enemy.behavior === 'melee') {
                        enemy.state = 'chasing';
                        const angle = Math.atan2(dy, dx);
                        enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
                        enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
                    } else if (enemy.behavior === 'ranged') {
                        enemy.state = 'aiming';
                        
                        if (distance < 250) {
                            const angle = Math.atan2(dy, dx);
                            enemy.x -= Math.cos(angle) * enemy.speed * 0.6 * deltaTime;
                            enemy.y -= Math.sin(angle) * enemy.speed * 0.6 * deltaTime;
                        } else if (distance > 350) {
                            const angle = Math.atan2(dy, dx);
                            enemy.x += Math.cos(angle) * enemy.speed * 0.8 * deltaTime;
                            enemy.y += Math.sin(angle) * enemy.speed * 0.8 * deltaTime;
                        }
                        
                        const now = Date.now();
                        if (now - enemy.lastAttack > enemy.attackCooldown) {
                            enemy.lastAttack = now;
                            enemy.state = 'attacking';
                            
                            const baseAngle = Math.atan2(dy, dx);
                            for (let i = 0; i < enemy.shotCount; i++) {
                                const spread = (i - (enemy.shotCount - 1) / 2) * enemy.shotSpread;
                                const angle = baseAngle + spread;
                                const bullet = {
                                    x: enemy.x + enemy.width / 2,
                                    y: enemy.y + enemy.height / 2,
                                    radius: 6,
                                    speed: 6 * deltaTime,
                                    dx: Math.cos(angle),
                                    dy: Math.sin(angle),
                                    damage: enemy.damage,
                                    color: enemy.color,
                                    fromEnemy: true,
                                    life: 180
                                };
                                
                                gameState.bullets.push(bullet);
                                createParticles(bullet.x, bullet.y, 4, enemy.color, 0.8);
                            }
                        }
                    } else if (enemy.behavior === 'evasive') {
                        enemy.state = 'evading';
                        const angle = Math.atan2(dy, dx);
                        enemy.x -= Math.cos(angle) * enemy.evasionSpeed * deltaTime;
                        enemy.y -= Math.sin(angle) * enemy.evasionSpeed * deltaTime;
                        
                        const now = Date.now();
                        if (now - enemy.lastAttack > enemy.attackCooldown) {
                            enemy.lastAttack = now;
                            enemy.state = 'attacking';
                            
                            const bullet = {
                                x: enemy.x + enemy.width / 2,
                                y: enemy.y + enemy.height / 2,
                                radius: 6,
                                speed: 8 * deltaTime,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: enemy.damage,
                                color: enemy.color,
                                fromEnemy: true,
                                life: 180
                            };
                            
                            gameState.bullets.push(bullet);
                            createParticles(bullet.x, bullet.y, 6, enemy.color, 0.8);
                        }
                    }
                } else {
                    enemy.state = 'patrol';
                    enemy.x += enemy.moveDirection * enemy.patrolSpeed * deltaTime;
                    
                    if (enemy.x <= enemy.patrolStartX || enemy.x >= enemy.patrolEndX) {
                        enemy.moveDirection = -enemy.moveDirection;
                    }
                }
                
                if (enemy.type === 'husk') {
                    enemy.y = enemy.originalY + Math.sin(Date.now() * 0.004 + enemy.x * 0.008) * 15;
                }
            });
        }

        function updateEnemyHitCooldowns(deltaTime) {
            for (const [key, cooldown] of gameState.enemyHitCooldowns) {
                if (cooldown > 0) {
                    gameState.enemyHitCooldowns.set(key, cooldown - deltaTime);
                } else {
                    gameState.enemyHitCooldowns.delete(key);
                }
            }
        }

        function shoot() {
            const player = gameState.player;
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.cooldown > 0) {
                return;
            }
            
            if (weapon.name === 'Nailgun' && weapon.overheatCooldown > 0) {
                return;
            }
            
            weapon.cooldown = weapon.maxCooldown;
            
            if (weapon.name === 'Nailgun') {
                weapon.shotsFired++;
                if (weapon.shotsFired >= weapon.maxShots) {
                    weapon.overheatCooldown = weapon.maxOverheatCooldown;
                    weapon.shotsFired = 0;
                    createTextParticles(player.x + player.width/2, player.y, 'OVERHEAT!', '#ff0000');
                }
            }
            
            let bulletCount = 1;
            let spread = 0;
            let damage = 15;
            let speed = 12;
            let color = weapon.bulletColor;
            let size = 5;
            
            switch (weapon.name) {
                case 'Revolver':
                    damage = 30;
                    speed = 15;
                    size = 6;
                    break;
                case 'Shotgun':
                    bulletCount = 11;
                    spread = 0.4;
                    damage = 7;
                    speed = 15;
                    size = 3;
                    break;
                case 'Nailgun':
                    bulletCount = 1;
                    spread = 0.1;
                    damage = 10;
                    speed = 22;
                    size = 3;
                    break;
                case 'Railgun':
                    damage = 200;
                    speed = 60;
                    size = 25;
                    break;
                case 'Rocket Launcher':
                    bulletCount = 1;
                    damage = 55;
                    speed = 10;
                    size = 10;
                    break;
            }
            
            damage *= player.bloodRageMultiplier;
            
            const angle = getAimAngle();
            
            for (let i = 0; i < bulletCount; i++) {
                const bulletAngle = angle + (Math.random() - 0.5) * spread;
                
                const bullet = {
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    radius: size,
                    speed: speed,
                    dx: Math.cos(bulletAngle),
                    dy: Math.sin(bulletAngle),
                    damage: damage,
                    color: color,
                    fromEnemy: false,
                    weaponType: weapon.name,
                    isSpecial: false,
                    life: 9999,
                    disappearOnHit: weapon.name !== 'Railgun' && weapon.name !== 'Rocket Launcher'
                };
                
                if (weapon.name === 'Rocket Launcher') {
                    bullet.rocket = true;
                    bullet.life = 1500;
                    bullet.explosionRadius = 200;
                  if (weapon.frozenRockets && weapon.freezeActive) {
        bullet.speed = 0; // NOVOS PROJ√âTEIS TAMB√âM CONGELADOS
        bullet.frozen = true;
    }
                    
                    weapon.activeRockets.push(bullet);
                } else if (weapon.name === 'Railgun') {
                    bullet.pierce = true;
                    bullet.pierceCount = 999;
                    bullet.life = 200;
                    bullet.pierceWalls = true;
                    bullet.railgun = true;
                    bullet.shockwave = true;
                    bullet.lightningEffect = true;
                } else if (weapon.name === 'Nailgun') {
                    bullet.nail = true;
                    bullet.life = 180;
                    bullet.horizontal = true;
                }
                
                gameState.bullets.push(bullet);
            }
            
            if (weapon.name === 'Railgun') {
                for (let i = 0; i < 25; i++) {
                    const sparkAngle = angle + (Math.random() - 0.5) * 0.3;
                    const sparkSpeed = Math.random() * 10 + 5;
                    createParticles(
                        player.x + player.width/2,
                        player.y + player.height/2,
                        1,
                        '#0066ff',
                        1.8
                    );
                }
                
                const beamLength = 100;
                const endX = player.x + player.width/2 + Math.cos(angle) * beamLength;
                const endY = player.y + player.height/2 + Math.sin(angle) * beamLength;
                
                for (let i = 0; i < 15; i++) {
                    const t = i / 15;
                    const segmentX = player.x + player.width/2 + Math.cos(angle) * (beamLength * t);
                    const segmentY = player.y + player.height/2 + Math.sin(angle) * (beamLength * t);
                    
                    createParticles(segmentX, segmentY, 3, '#0066ff', 1.2);
                }
                
                gameState.camera.shake = 25;
                gameState.camera.shakeIntensity = 18;
                
                addStylePoints(15, 'RAILGUN SHOT');
            } else {
                createParticles(player.x + player.width/2, player.y + player.height/2, 8, color, 0.8);
                addStylePoints(1, 'SHOT');
                
                if (weapon.name === 'Shotgun' || weapon.name === 'Rocket Launcher') {
                    gameState.camera.shake = 8;
                    gameState.camera.shakeIntensity = 5;
                }
            }
            
            updateUI();
        }

        function useWeaponSpecial() {
            const player = gameState.player;
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.specialCooldown > 0 || !weapon.special) return;
            
            weapon.specialCooldown = weapon.maxSpecialCooldown;
            
            switch (weapon.name) {
                case 'Shotgun':
                    const explosiveBullet = {
                        x: player.x + player.width / 2,
                        y: player.y + player.height / 2,
                        radius: 8,
                        speed: 15,
                        dx: Math.cos(getAimAngle()),
                        dy: Math.sin(getAimAngle()),
                        damage: 80 * player.bloodRageMultiplier,
                        color: weapon.specialColor,
                        fromEnemy: false,
                        isSpecial: true,
                        explosive: true,
                        explosionRadius: 150,
                        weaponType: weapon.name,
                        life: 180
                    };
                    gameState.bullets.push(explosiveBullet);
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = getAimAngle() + (Math.random() - 0.5) * 0.5;
                        createParticles(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            1,
                            weapon.specialColor,
                            1
                        );
                    }
                    
                    addStylePoints(20, 'EXPLOSIVESHELL');
                    break;
                    
                case 'Nailgun':
                    const magnetNail = {
                        x: player.x + player.width / 2,
                        y: player.y + player.height / 2,
                        radius: 6,
                        speed: 12,
                        dx: Math.cos(getAimAngle()),
                        dy: Math.sin(getAimAngle()),
                        damage: 0,
                        color: weapon.specialColor,
                        fromEnemy: false,
                        isSpecial: true,
                        magnetNail: true,
                        weaponType: weapon.name,
                        life: 300
                    };
                    gameState.bullets.push(magnetNail);
                    gameState.magnetNails.push(magnetNail);
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const distance = 20;
                        const particleX = player.x + player.width/2 + Math.cos(angle) * distance;
                        const particleY = player.y + player.height/2 + Math.sin(angle) * distance;
                        createParticles(particleX, particleY, 1, weapon.specialColor, 1);
                    }
                    
                    addStylePoints(15, 'MAGNETNAIL');
                    break;
            }
            
            gameState.camera.shake = 20;
            gameState.camera.shakeIntensity = 10;
            
            updateUI();
        }

        function getAimAngle() {
            const player = gameState.player;
            const rect = canvas.getBoundingClientRect();
            const mouseX = gameState.mouse.x;
            const mouseY = gameState.mouse.y;
            const playerScreenX = player.x - gameState.camera.x + player.width / 2;
            const playerScreenY = player.y - gameState.camera.y + player.height / 2;
            return Math.atan2(mouseY - playerScreenY, mouseX - playerScreenX);
        }

        function updateBullets(deltaTime) {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                if (bullet.orbiting || bullet.movingToMagnet) continue;
                
                bullet.x += bullet.dx * bullet.speed * deltaTime;
                bullet.y += bullet.dy * bullet.speed * deltaTime;
                
                bullet.life--;
                if (bullet.life <= 0 && !bullet.noCollision) {
                    gameState.bullets.splice(i, 1);
                    continue;
                }
                
                if (!bullet.pierceWalls && !bullet.noCollision && bullet.weaponType !== 'Rocket Launcher') {
                    let hitWall = false;
                    gameState.platforms.forEach(platform => {
                        if (platform.solid && platform.type !== 'ground' &&
                            bullet.x > platform.x && 
                            bullet.x < platform.x + platform.width &&
                            bullet.y > platform.y && 
                            bullet.y < platform.y + platform.height) {
                            hitWall = true;
                        }
                    });
                    
                    if (hitWall && !bullet.rocket) {
                        createParticles(bullet.x, bullet.y, 5, bullet.color, 0.8);
                        gameState.bullets.splice(i, 1);
                        continue;
                    }
                }
                
                if (bullet.rocket) {
                    gameState.platforms.forEach(platform => {
                        if (platform.solid &&
                            bullet.x > platform.x && 
                            bullet.x < platform.x + platform.width &&
                            bullet.y > platform.y && 
                            bullet.y < platform.y + platform.height) {
                            
                            createExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            gameState.bullets.splice(i, 1);
                            
                            const rocketLauncher = gameState.player.weapons[4];
                            const rocketIndex = rocketLauncher.activeRockets.indexOf(bullet);
                            if (rocketIndex !== -1) {
                                rocketLauncher.activeRockets.splice(rocketIndex, 1);
                            }
                        }
                    });
                }
                
                if (bullet.beam && !bullet.pierce) {
                    gameState.platforms.forEach(platform => {
                        if (platform.solid && platform.type !== 'ground') {
                            const endX = bullet.x + Math.cos(bullet.angle) * bullet.length;
                            const endY = bullet.y + Math.sin(bullet.angle) * bullet.length;
                            
                            if (lineRectIntersection(bullet.x, bullet.y, endX, endY, platform.x, platform.y, platform.width, platform.height)) {
                                bullet.life = 0;
                            }
                        }
                    });
                }
                
                if (bullet.x < gameState.camera.x - 500 || 
                    bullet.x > gameState.camera.x + canvas.width + 500 ||
                    bullet.y < gameState.camera.y - 500 || 
                    bullet.y > gameState.camera.y + canvas.height + 500) {
                    
                    gameState.bullets.splice(i, 1);
                    continue;
                }
                if (bullet.fireball && bullet.willSplit && bullet.splitTime > 0) {
    bullet.splitTime--;
    
    // Efeito visual antes da divis√£o
    if (bullet.splitTime < 60 && Math.random() < 0.3) {
        createParticles(bullet.x, bullet.y, 2, '#ffff00', 1.2);
    }
    
    if (bullet.splitTime <= 0) {
        // Dividir em 3 bolas menores
        for (let j = 0; j < bullet.splitCount; j++) {
            const splitAngle = Math.atan2(bullet.dy, bullet.dx) + (j - 1) * 0.5;
            const splitBullet = {
                x: bullet.x,
                y: bullet.y,
                radius: 12,
                speed: 9,
                dx: Math.cos(splitAngle),
                dy: Math.sin(splitAngle),
                damage: bullet.damage * 0.6,
                color: '#ff8800',
                fromEnemy: true,
                life: 150,
                fireball: true,
                willSplit: false // N√£o se dividem novamente
            };
            
            gameState.bullets.push(splitBullet);
            
            // Efeito da divis√£o
            for (let k = 0; k < 5; k++) {
                createParticles(
                    bullet.x,
                    bullet.y,
                    1,
                    '#ffaa00',
                    1.5
                );
            }
        }
        
        // Remover bola original
        gameState.bullets.splice(i, 1);
        continue;
    }
}
                if (bullet.isSpecial) {
                    if (bullet.explosive && bullet.speed > 0) {
                        bullet.speed *= 0.97;
                        if (bullet.speed < 3) {
                            createExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            gameState.bullets.splice(i, 1);
                            continue;
                        }
                    }
                }
            }
        }

        function lineRectIntersection(x1, y1, x2, y2, rx, ry, rw, rh) {
            function lineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
                const uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
                const uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
                return (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1);
            }
            
            const left = lineLine(x1, y1, x2, y2, rx, ry, rx, ry+rh);
            const right = lineLine(x1, y1, x2, y2, rx+rw, ry, rx+rw, ry+rh);
            const top = lineLine(x1, y1, x2, y2, rx, ry, rx+rw, ry);
            const bottom = lineLine(x1, y1, x2, y2, rx, ry+rh, rx+rw, ry+rh);
            
            return (left || right || top || bottom);
        }

        function updateParticles(deltaTime) {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                particle.x += particle.dx * deltaTime;
                particle.y += particle.dy * deltaTime;
                particle.dy += 0.15 * deltaTime;
                particle.life--;
                
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function updatePickups(deltaTime) {
            gameState.pickups.forEach(pickup => {
                pickup.offsetY = pickup.offsetY || 0;
                pickup.offsetY = Math.sin(Date.now() * 0.005 + pickup.x * 0.008) * 8;
                
                if (pickup.type === 'coin' || pickup.type === 'health') {
                    pickup.rotation = pickup.rotation || 0;
                    pickup.rotation += 0.06 * deltaTime;
                }
            });
        }

        function updateBoss(deltaTime) {
            if (!gameState.currentBoss || !gameState.bossActive) return;
    
    const boss = gameState.currentBoss;
    const player = gameState.player;
    
    // SEMPRE detectar o jogador, n√£o importa a dist√¢ncia
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToPlayer = Math.atan2(dy, dx);
    
    const now = Date.now();
    
    // Comportamento baseado no estado
    if (boss.chargeBeamCharging) {
        // Modo: Carregando Dash
        boss.chargeBeamTime += deltaTime;
        
        const chargePercent = boss.chargeBeamTime / boss.chargeBeamDuration;
        const aura = document.getElementById('cerberusChargeAura');
        aura.style.display = 'block';
        aura.style.left = `${boss.x - gameState.camera.x + boss.width/2}px`;
        aura.style.top = `${boss.y - gameState.camera.y + boss.height/2}px`;
        aura.style.width = `${400 * (1 - chargePercent)}px`;
        aura.style.height = `${400 * (1 - chargePercent)}px`;
        
        // Criar part√≠culas de carga
        if (Math.random() < 0.5) {
            const particleAngle = Math.random() * Math.PI * 2;
            const particleDist = 200 * (1 - chargePercent);
            createParticles(
                boss.x + boss.width/2 + Math.cos(particleAngle) * particleDist,
                boss.y + boss.height/2 + Math.sin(particleAngle) * particleDist,
                1,
                '#ff0000',
                2
            );
        }
        
        if (boss.chargeBeamTime >= boss.chargeBeamDuration) {
            // Dash carregado - executar!
            boss.chargeBeamCharging = false;
            
            // Efeito visual antes do dash
            for (let i = 0; i < 50; i++) {
                const particleAngle = Math.random() * Math.PI * 2;
                createParticles(
                    boss.x + boss.width/2,
                    boss.y + boss.height/2,
                    1,
                    '#ff3300',
                    3
                );
            }
            
            gameState.camera.shake = 60;
            gameState.camera.shakeIntensity = 30;
            
            // Configurar dash
            boss.dashCharged = true;
            boss.dashAngle = angleToPlayer;
            boss.dashDistance = 0;
            boss.maxDashDistance = 800;
            
            document.getElementById('cerberusDashTrail').style.display = 'block';
        }
        
    } else if (boss.dashCharged) {
        // Modo: Executando Dash
        const dashSpeed = boss.dashSpeed * 1.5;
        boss.x += Math.cos(boss.dashAngle) * dashSpeed * deltaTime;
        boss.y += Math.sin(boss.dashAngle) * dashSpeed * deltaTime;
        boss.dashDistance += dashSpeed * deltaTime;
        
        // Trilha do dash
        for (let i = 0; i < 3; i++) {
            const trailX = boss.x - Math.cos(boss.dashAngle) * i * 20;
            const trailY = boss.y - Math.sin(boss.dashAngle) * i * 20;
            gameState.cerberusDashTrail.push({
                x: trailX,
                y: trailY,
                life: 20 + i * 5
            });
        }
        
        // Aura durante o dash
        const dashAura = document.getElementById('bossDashAura');
        dashAura.style.display = 'block';
        dashAura.style.left = `${boss.x - gameState.camera.x + boss.width/2}px`;
        dashAura.style.top = `${boss.y - gameState.camera.y + boss.height/2}px`;
        dashAura.style.width = '150px';
        dashAura.style.height = '150px';
        
        // Verificar colis√£o com jogador durante dash
        if (distance < 80) {
            player.health -= boss.dashDamage;
            const knockbackAngle = angleToPlayer;
            player.velocityX = Math.cos(knockbackAngle) * boss.dashKnockback;
            player.velocityY = Math.sin(knockbackAngle) * boss.dashKnockback;
            
            createParticles(player.x + player.width/2, player.y + player.height/2, 30, '#ff0000', 2);
            showDamageIndicator();
            gameState.camera.shake = 40;
            gameState.camera.shakeIntensity = 20;
            
            if (player.health <= 0) {
                gameOver();
            }
            
            updateUI();
        }
        
        // Finalizar dash
        if (boss.dashDistance >= boss.maxDashDistance || boss.dashDistance > 1000) {
            boss.dashCharged = false;
            boss.lastDashTime = now;
            boss.dashCooldownTime = 20000; // 20 segundos de cooldown
            
            document.getElementById('cerberusChargeAura').style.display = 'none';
            document.getElementById('cerberusDashTrail').style.display = 'none';
            document.getElementById('bossDashAura').style.display = 'none';
            
            // Efeito de impacto
            for (let i = 0; i < 30; i++) {
                const impactAngle = Math.random() * Math.PI * 2;
                createParticles(
                    boss.x + boss.width/2,
                    boss.y + boss.height/2,
                    1,
                    '#ff5500',
                    2.5
                );
            }
        }
        
    } else {
        // Modo: Normal - sempre seguir jogador
        if (distance > 100) {
            boss.x += Math.cos(angleToPlayer) * boss.speed * deltaTime;
            boss.y += Math.sin(angleToPlayer) * boss.speed * deltaTime;
        }
        
        // Atirar diretamente no jogador (tiros retos)
        if (now - boss.lastAttack > boss.attackCooldown) {
            boss.lastAttack = now;
            
            // Tiro direto e preciso
            const bullet = {
                x: boss.x + boss.width / 2,
                y: boss.y + boss.height / 2,
                radius: 18,
                speed: 12 * deltaTime,
                dx: Math.cos(angleToPlayer),
                dy: Math.sin(angleToPlayer),
                damage: boss.damage,
                color: '#ff5500',
                fromEnemy: true,
                life: 300,
                homing: true,
                targetX: player.x + player.width/2,
                targetY: player.y + player.height/2
            };
            
            gameState.bullets.push(bullet);
            
            // Efeito do tiro
            for (let i = 0; i < 10; i++) {
                createParticles(
                    bullet.x + (Math.random() - 0.5) * 15,
                    bullet.y + (Math.random() - 0.5) * 15,
                    1,
                    '#ff8800',
                    1.5
                );
            }
            
            // Ataques especiais aleat√≥rios
            if (boss.specialAttackCooldown <= 0) {
                if (Math.random() < 0.3) {
                    // Ataque de 3 bolas em leque
                    performCerberusFireballAttack(boss, player);
                    boss.specialAttackCooldown = 180;
                } else if (now - boss.lastDashTime > boss.dashCooldownTime && Math.random() < 0.15) {
                    // Iniciar carga do dash
                    boss.chargeBeamCharging = true;
                    boss.chargeBeamTime = 0;
                    boss.chargeBeamDuration = 180; // 3 segundos (60fps * 3)
                    
                    // Aviso visual
                    createTextParticles(boss.x + boss.width/2, boss.y, 'DASH CARREGANDO!', '#ff0000');
                }
            }
        }
    }
    
    // Atualizar cooldowns
    if (boss.specialAttackCooldown > 0) {
        boss.specialAttackCooldown--;
    }
    
    // Atualizar barra de vida na UI
    if (gameState.bossActive) {
        const healthPercent = boss.health / boss.maxHealth;
        document.getElementById('enemyHealthFill').style.width = `${healthPercent * 100}%`;
        
        // Fase 2 (50% de vida)
        if (healthPercent <= 0.5 && boss.phase === 1) {
            boss.phase = 2;
            boss.speed *= 1.8;
            boss.attackCooldown *= 0.6;
            
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 100;
                createParticles(
                    boss.x + boss.width/2 + Math.cos(angle) * distance,
                    boss.y + boss.height/2 + Math.sin(angle) * distance,
                    1,
                    '#ff0000',
                    2
                );
            }
            
            createTextParticles(boss.x + boss.width/2, boss.y, 'FASE 2! VELOCIDADE AUMENTADA!', '#ff0000');
        }
    

            } else {
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < boss.attackRange) {
                    const angle = Math.atan2(dy, dx);
                    boss.x += Math.cos(angle) * boss.speed * deltaTime;
                    boss.y += Math.sin(angle) * boss.speed * deltaTime;
                }
                
                const now = Date.now();
                if (now - boss.lastAttack > boss.attackCooldown) {
                    boss.lastAttack = now;
                    
                    const angle = Math.atan2(dy, dx);
                    const bullet = {
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        radius: 14,
                        speed: 8 * deltaTime,
                        dx: Math.cos(angle),
                        dy: Math.sin(angle),
                        damage: boss.damage,
                        color: boss.color,
                        fromEnemy: true,
                        life: 240
                    };
                    
                    gameState.bullets.push(bullet);
                    
                    for (let i = 0; i < 8; i++) {
                        createParticles(
                            bullet.x + (Math.random() - 0.5) * 10,
                            bullet.y + (Math.random() - 0.5) * 10,
                            1,
                            boss.color,
                            1.2
                        );
                    }
                    
                    if (boss.specialAttackCooldown <= 0 && Math.random() < 0.15) {
                        boss.specialAttackCooldown = 200;
                        performBossSpecialAttack(boss);
                    }
                }
            }
            
            if (boss.specialAttackCooldown > 0) {
                boss.specialAttackCooldown--;
            }
            
            const healthPercent = boss.health / boss.maxHealth;
            if (healthPercent <= boss.phaseThreshold && boss.phase === 1) {
                boss.phase = 2;
                boss.speed *= 1.5;
                boss.attackCooldown *= 0.7;
                
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 50;
                    createParticles(
                        boss.x + boss.width/2 + Math.cos(angle) * distance,
                        boss.y + boss.height/2 + Math.sin(angle) * distance,
                        1,
                        '#ff0000',
                        1.5
                    );
                }
                
                createTextParticles(boss.x + boss.width/2, boss.y, 'PHASE 2!', '#ff0000');
            }
            
            if (gameState.bossActive) {
                const healthPercent = boss.health / boss.maxHealth;
                document.getElementById('enemyHealthFill').style.width = `${healthPercent * 100}%`;
            }
        }
function performCerberusFireballAttack(boss, player) {
    const baseAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
    
    // Lan√ßar 3 bolas em leque
    for (let i = 0; i < 3; i++) {
        const spread = (i - 1) * 0.4; // -0.4, 0, +0.4
        const angle = baseAngle + spread;
        
        const fireball = {
            x: boss.x + boss.width / 2,
            y: boss.y + boss.height / 2,
            radius: 22,
            speed: 7,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            damage: boss.damage * 1.5,
            color: '#ff5500',
            fromEnemy: true,
            life: 180,
            fireball: true,
            splitTime: 120, // 2 segundos para se dividir (60fps * 2)
            willSplit: true,
            splitCount: 3
        };
        
        gameState.bullets.push(fireball);
        
        // Efeito do lan√ßamento
        for (let j = 0; j < 8; j++) {
            createParticles(
                fireball.x,
                fireball.y,
                1,
                '#ff8800',
                1.8
            );
        }
    }
    
    // Efeito visual
    gameState.camera.shake = 40;
    gameState.camera.shakeIntensity = 20;
    
    // Somar pontos de estilo
    addStylePoints(15, 'FIREBALL ATTACK');
}
        function updateBossDash(deltaTime) {
            for (let i = gameState.bossDashTrail.length - 1; i >= 0; i--) {
                const trail = gameState.bossDashTrail[i];
                trail.life--;
                
                if (trail.life <= 0) {
                    gameState.bossDashTrail.splice(i, 1);
                }
            }
        }

        function performBossSpecialAttack(boss) {
            const player = gameState.player;
            
            switch (boss.type) {
                case 'cerberus':
                    for (let i = 0; i < 3; i++) {
                        const baseAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        const angle = baseAngle + (i - 1) * 0.3;
                        const fireball = {
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height / 2,
                            radius: 15,
                            speed: 7,
                            dx: Math.cos(angle),
                            dy: Math.sin(angle),
                            damage: boss.damage * 1.2,
                            color: '#ff5500',
                            fromEnemy: true,
                            life: 180,
                            fireball: true,
                            splitTime: 120,
                            splitCount: 3
                        };
                        gameState.bullets.push(fireball);
                        
                        for (let j = 0; j < 6; j++) {
                            createParticles(
                                fireball.x,
                                fireball.y,
                                1,
                                '#ff8800',
                                1
                            );
                        }
                    }
                    
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        createParticles(
                            boss.x + boss.width/2,
                            boss.y + boss.height/2,
                            1,
                            '#ff5500',
                            1.8
                        );
                    }
                    break;
                    
                case 'forge_demon':
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const bullet = {
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height / 2,
                            radius: 12,
                            speed: 6,
                            dx: Math.cos(angle),
                            dy: Math.sin(angle),
                            damage: boss.damage * 0.8,
                            color: '#ff3300',
                            fromEnemy: true,
                            life: 120
                        };
                        gameState.bullets.push(bullet);
                    }
                    
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 60;
                        createParticles(
                            boss.x + boss.width/2 + Math.cos(angle) * distance,
                            boss.y + boss.height/2 + Math.sin(angle) * distance,
                            1,
                            '#ff3300',
                            1.8
                        );
                    }
                    break;
                    
                case 'archdemon':
                    const beamAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    const beam = {
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        length: 1000,
                        width: 30,
                        angle: beamAngle,
                        damage: boss.damage * 2,
                        color: '#ff00ff',
                        life: 40,
                        fromEnemy: true,
                        isSpecial: true,
                        beam: true
                    };
                    gameState.bullets.push(beam);
                    
                    for (let i = 0; i < 30; i++) {
                        const segmentX = beam.x + Math.cos(beamAngle) * (i * 40);
                        const segmentY = beam.y + Math.sin(beamAngle) * (i * 40);
                        createParticles(segmentX, segmentY, 2, '#ff00ff', 1.5);
                    }
                    
                    if (Math.random() < 0.5) {
                        performArchdemonChainLightning(boss);
                    } else {
                        performArchdemonVoidVortex(boss);
                    }
                    break;
            }
            
            gameState.camera.shake = 40;
            gameState.camera.shakeIntensity = 20;
        }

        function performArchdemonChainLightning(boss) {
            const player = gameState.player;
            
            for (let i = 0; i < 3; i++) {
                const startX = boss.x + boss.width/2 + (Math.random() - 0.5) * 50;
                const startY = boss.y + boss.height/2 + (Math.random() - 0.5) * 50;
                
                const segments = 8;
                let currentX = startX;
                let currentY = startY;
                let targetX = player.x + (Math.random() - 0.5) * 100;
                let targetY = player.y + (Math.random() - 0.5) * 100;
                
                for (let j = 0; j < segments; j++) {
                    const nextX = startX + (targetX - startX) * (j/segments) + (Math.random() - 0.5) * 40;
                    const nextY = startY + (targetY - startY) * (j/segments) + (Math.random() - 0.5) * 40;
                    
                    const segment = {
                        x: currentX,
                        y: currentY,
                        length: Math.sqrt((nextX - currentX)**2 + (nextY - currentY)**2),
                        width: 8,
                        angle: Math.atan2(nextY - currentY, nextX - currentX),
                        damage: boss.damage * 0.5,
                        color: '#00ffff',
                        life: 10,
                        fromEnemy: true,
                        isSpecial: true,
                        beam: true,
                        lightning: true
                    };
                    gameState.bullets.push(segment);
                    
                    currentX = nextX;
                    currentY = nextY;
                }
            }
            
            addStylePoints(25, 'CHAIN LIGHTNING');
        }

        function performArchdemonVoidVortex(boss) {
            const vortex = {
                x: boss.x + boss.width/2,
                y: boss.y + boss.height/2,
                radius: 0,
                maxRadius: 200,
                damage: boss.damage * 0.3,
                color: '#9900ff',
                life: 120,
                fromEnemy: true,
                vortex: true
            };
            
            gameState.bullets.push(vortex);
            
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 150;
                createParticles(
                    vortex.x + Math.cos(angle) * distance,
                    vortex.y + Math.sin(angle) * distance,
                    1,
                    '#9900ff',
                    1.2
                );
            }
            
            addStylePoints(30, 'VOID VORTEX');
        }

        function updateStyle(deltaTime) {
            const now = Date.now();
            if (now - gameState.lastKillTime > gameState.comboTime) {
                gameState.stylePoints = Math.max(0, gameState.stylePoints - 0.8 * deltaTime);
                
                if (now - gameState.lastKillTime > gameState.comboTime * 2) {
                    if (gameState.killCombo > 0) {
                        addStylePoints(-Math.floor(gameState.killCombo / 2), 'COMBO LOST');
                    }
                    gameState.killCombo = 0;
                    document.getElementById('comboCounter').style.display = 'none';
                }
            }
            
            let rankName = 'D - DEMIURGO';
            if (gameState.stylePoints < 15) {
                gameState.styleRank = 'D';
                gameState.styleMultiplier = 1;
                rankName = 'D - DEMIURGO';
                gameState.timeScale = 1;
            } else if (gameState.stylePoints < 35) {
                gameState.styleRank = 'C';
                gameState.styleMultiplier = 1.3;
                rankName = 'C - COZINHANDO';
                gameState.timeScale = 1;
            } else if (gameState.stylePoints < 70) {
                gameState.styleRank = 'B';
                gameState.styleMultiplier = 1.7;
                rankName = 'B - BLUEZ√ÉO';
                gameState.timeScale = 1;
            } else if (gameState.stylePoints < 140) {
                gameState.styleRank = 'A';
                gameState.styleMultiplier = 2.2;
                rankName = 'A - ADOLF';
                gameState.timeScale = 1;
            } else if (gameState.stylePoints < 280) {
                gameState.styleRank = 'S';
                gameState.styleMultiplier = 3;
                rankName = 'S - STALIN';
                gameState.timeScale = 1;
            } else {
                gameState.styleRank = 'SS';
                gameState.styleMultiplier = 4;
                rankName = 'SS - AURA+EGO';
                gameState.timeScale = 1;
            }
            
            const stylePercent = Math.min(100, gameState.stylePoints / 3);
            document.getElementById('styleFill').style.width = `${stylePercent}%`;
            document.getElementById('styleRank').textContent = gameState.styleRank;
            document.getElementById('styleText').textContent = rankName;
        }

        function addStylePoints(points, type) {
            if (points === 0) return;
            
            const actualPoints = Math.floor(points * gameState.styleMultiplier);
            gameState.stylePoints += actualPoints;
            gameState.lastKillTime = Date.now();
            
            gameState.styleEvents.push({
                type: type,
                value: actualPoints,
                life: 120
            });
            
            if (gameState.styleEvents.length > 10) {
                gameState.styleEvents.shift();
            }
        }

        function createExplosion(x, y, radius, damage) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                createParticles(
                    x + Math.cos(angle) * distance,
                    y + Math.sin(angle) * distance,
                    1,
                    '#ff7700',
                    1.5
                );
            }
            
            gameState.shockwaves.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: radius * 1.5,
                speed: 8,
                life: 30
            });
            
            gameState.enemies.forEach(enemy => {
                const dx = enemy.x + enemy.width/2 - x;
                const dy = enemy.y + enemy.height/2 - y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < radius) {
                    const damagePercent = 1 - (dist / radius);
                    const actualDamage = damage * damagePercent * gameState.player.bloodRageMultiplier;
                    enemy.health -= actualDamage;
                    
                    const angle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(angle) * 15 * damagePercent;
                    enemy.y += Math.sin(angle) * 12 * damagePercent;
                    
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 10, '#ff0000', 0.8);
                    
                    if (enemy.health <= 0) {
                        enemyKilled(enemy);
                    }
                }
            });
            
            if (gameState.currentBoss) {
                const boss = gameState.currentBoss;
                const dx = boss.x + boss.width/2 - x;
                const dy = boss.y + boss.height/2 - y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < radius) {
                    const damagePercent = 1 - (dist / radius);
                    const actualDamage = damage * damagePercent * gameState.player.bloodRageMultiplier * 0.7;
                    boss.health -= actualDamage;
                    
                    createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 15, '#ff0000', 1);
                    
                    if (boss.health <= 0) {
                        bossKilled(boss);
                    }
                }
            }
            
            gameState.camera.shake = 25;
            gameState.camera.shakeIntensity = 12;
            
            addStylePoints(Math.floor(damage / 10), 'EXPLOSION');
        }

        function createShockwave(x, y, radius, damage) {
            gameState.shockwaves.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: radius,
                speed: 6,
                life: 40
            });
            
            gameState.enemies.forEach(enemy => {
                const dx = enemy.x + enemy.width/2 - x;
                const dy = enemy.y + enemy.height/2 - y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < radius) {
                    const damagePercent = 1 - (dist / radius);
                    const actualDamage = damage * damagePercent;
                    enemy.health -= actualDamage;
                    
                    const angle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(angle) * 10 * damagePercent;
                    enemy.y += Math.sin(angle) * 8 * damagePercent;
                    
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 8, '#00aaff', 0.8);
                    
                    if (enemy.health <= 0) {
                        enemyKilled(enemy);
                    }
                }
            });
            
            gameState.camera.shake = 15;
            gameState.camera.shakeIntensity = 8;
            
            addStylePoints(Math.floor(damage / 5), 'SHOCKWAVE');
        }

        function checkCollisions() {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                if (bullet.fromEnemy || bullet.noCollision || bullet.beam || bullet.vortex) continue;
                
                if (bullet.vortex) {
                    bullet.radius += 2;
                    if (bullet.radius > bullet.maxRadius) {
                        bullet.radius = bullet.maxRadius;
                    }
                    
                    gameState.enemies.forEach(enemy => {
                        const dx = enemy.x + enemy.width/2 - bullet.x;
                        const dy = enemy.y + enemy.height/2 - bullet.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < bullet.radius) {
                            const pullForce = 0.5;
                            const angle = Math.atan2(dy, dx);
                            enemy.x += Math.cos(angle) * pullForce;
                            enemy.y += Math.sin(angle) * pullForce;
                            
                            if (dist < bullet.radius * 0.5) {
                                enemy.health -= bullet.damage;
                                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 3, bullet.color, 0.6);
                                
                                if (enemy.health <= 0) {
                                    enemyKilled(enemy);
                                    gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                                }
                            }
                        }
                    });
                    
                    bullet.life--;
                    if (bullet.life <= 0) {
                        gameState.bullets.splice(i, 1);
                    }
                    continue;
                }
                
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    
                    if (bullet.x > enemy.x && 
                        bullet.x < enemy.x + enemy.width &&
                        bullet.y > enemy.y && 
                        bullet.y < enemy.y + enemy.height) {
                        
                        const enemyKey = `${enemy.x}-${enemy.y}`;
                        const lastHit = gameState.enemyHitCooldowns.get(enemyKey) || 0;
                        
                        if (bullet.weaponType === 'Rocket Launcher' || 
                            (bullet.weaponType === 'Shotgun' && bullet.isSpecial)) {
                            
                            if (Date.now() - lastHit < 1000) {
                                continue;
                            }
                            gameState.enemyHitCooldowns.set(enemyKey, Date.now());
                        }
                        
                        const actualDamage = bullet.damage * gameState.player.bloodRageMultiplier;
                        enemy.health -= actualDamage;
                        
                        createParticles(bullet.x, bullet.y, 8, '#ff0000', 0.8);
                        
                        let styleType = 'HIT';
                        if (bullet.weaponType === 'Railgun') styleType = 'RAIL';
                        else if (bullet.weaponType === 'Shotgun') styleType = 'SHOTGUN';
                        else if (bullet.weaponType === 'Nailgun') styleType = 'NAIL';
                        else if (bullet.weaponType === 'Rocket Launcher') styleType = 'ROCKET';
                        
                        addStylePoints(Math.floor(actualDamage / 5), styleType);
                        
                        if (bullet.disappearOnHit) {
                            if (bullet.pierce) {
                                bullet.pierceCount--;
                                if (bullet.pierceCount <= 0) {
                                    gameState.bullets.splice(i, 1);
                                }
                            } else if (!bullet.pierce && !bullet.rocket) {
                                gameState.bullets.splice(i, 1);
                            }
                        }
                        
                        if (bullet.rocket) {
                            createExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            gameState.bullets.splice(i, 1);
                            
                            const rocketLauncher = gameState.player.weapons[4];
                            const rocketIndex = rocketLauncher.activeRockets.indexOf(bullet);
                            if (rocketIndex !== -1) {
                                rocketLauncher.activeRockets.splice(rocketIndex, 1);
                            }
                        }
                        
                        if (enemy.health <= 0) {
                            enemyKilled(enemy);
                            gameState.enemies.splice(j, 1);
                        }
                        
                        if (!bullet.pierce) break;
                    }
                }
                
                if (gameState.currentBoss) {
                    const boss = gameState.currentBoss;
                    
                    if (bullet.x > boss.x && 
                        bullet.x < boss.x + boss.width &&
                        bullet.y > boss.y && 
                        bullet.y < boss.y + boss.height) {
                        
                        const bossKey = `boss-${boss.type}`;
                        const lastHit = gameState.enemyHitCooldowns.get(bossKey) || 0;
                        
                        if (bullet.weaponType === 'Rocket Launcher' || 
                            (bullet.weaponType === 'Shotgun' && bullet.isSpecial)) {
                            
                            if (Date.now() - lastHit < 1000) {
                                continue;
                            }
                            gameState.enemyHitCooldowns.set(bossKey, Date.now());
                        }
                        
                        const actualDamage = bullet.damage * gameState.player.bloodRageMultiplier;
                        boss.health -= actualDamage;
                        
                        createParticles(bullet.x, bullet.y, 10, '#ff0000', 1);
                        addStylePoints(Math.floor(actualDamage / 3), 'BOSS HIT');
                        
                        if (bullet.disappearOnHit) {
                            if (bullet.pierce) {
                                bullet.pierceCount--;
                                if (bullet.pierceCount <= 0) {
                                    gameState.bullets.splice(i, 1);
                                }
                            } else if (!bullet.pierce && !bullet.rocket) {
                                gameState.bullets.splice(i, 1);
                            }
                        }
                        
                        if (bullet.rocket) {
                            createExplosion(bullet.x, bullet.y, bullet.explosionRadius, bullet.damage);
                            gameState.bullets.splice(i, 1);
                            
                            const rocketLauncher = gameState.player.weapons[4];
                            const rocketIndex = rocketLauncher.activeRockets.indexOf(bullet);
                            if (rocketIndex !== -1) {
                                rocketLauncher.activeRockets.splice(rocketIndex, 1);
                            }
                        }
                        
                        if (boss.health <= 0) {
                            bossKilled(boss);
                        }
                        
                        if (!bullet.pierce) break;
                    }
                }
            }
            
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                if (!bullet.fromEnemy) continue;
                
                const player = gameState.player;
                if (bullet.x > player.x && 
                    bullet.x < player.x + player.width &&
                    bullet.y < player.y + player.height &&
                    bullet.y > player.y) {
                    
                    player.health -= bullet.damage;
                    
                    createParticles(bullet.x, bullet.y, 8, '#ff0000', 1);
                    showDamageIndicator();
                    gameState.stylePoints = Math.max(0, gameState.stylePoints - 20);
                    gameState.camera.shake = 12;
                    gameState.camera.shakeIntensity = 6;
                    gameState.bullets.splice(i, 1);
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                    
                    updateUI();
                    break;
                }
            }
            
            const player = gameState.player;
            const now = Date.now();
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    if (now - player.lastEnemyCollisionDamage > player.enemyCollisionCooldown) {
                        player.health -= enemy.damage;
                        player.lastEnemyCollisionDamage = now;
                        showDamageIndicator();
                        gameState.stylePoints = Math.max(0, gameState.stylePoints - 15);
                        
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const angle = Math.atan2(dy, dx);
                        player.velocityX = Math.cos(angle) * 12;
                        player.velocityY = Math.sin(angle) * 8;
                        
                        createParticles(player.x + player.width/2, player.y + player.height/2, 8, '#ff0000', 0.8);
                        gameState.camera.shake = 8;
                        gameState.camera.shakeIntensity = 4;
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                        
                        updateUI();
                    }
                    break;
                }
            }
            
            if (gameState.currentBoss) {
                const boss = gameState.currentBoss;
                
                if (player.x < boss.x + boss.width &&
                    player.x + player.width > boss.x &&
                    player.y < boss.y + boss.height &&
                    player.y + player.height > boss.y) {
                    
                    if (now - player.lastEnemyCollisionDamage > player.enemyCollisionCooldown) {
                        player.health -= boss.damage;
                        player.lastEnemyCollisionDamage = now;
                        showDamageIndicator();
                        gameState.stylePoints = Math.max(0, gameState.stylePoints - 25);
                        
                        const dx = player.x - boss.x;
                        const dy = player.y - boss.y;
                        const angle = Math.atan2(dy, dx);
                        player.velocityX = Math.cos(angle) * 15;
                        player.velocityY = Math.sin(angle) * 10;
                        
                        createParticles(player.x + player.width/2, player.y + player.height/2, 10, '#ff0000', 1);
                        gameState.camera.shake = 10;
                        gameState.camera.shakeIntensity = 6;
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                        
                        updateUI();
                    }
                }
            }
            
            for (let i = gameState.pickups.length - 1; i >= 0; i--) {
                const pickup = gameState.pickups[i];
                const pickupY = pickup.y + (pickup.offsetY || 0);
                
                if (player.x < pickup.x + 25 &&
                    player.x + player.width > pickup.x &&
                    player.y < pickupY + 25 &&
                    player.y + player.height > pickupY) {
                    
                    collectPickup(pickup);
                    gameState.pickups.splice(i, 1);
                }
            }
            
            if (player.velocityY > 15 && player.isGrounded) {
                createShockwave(player.x + player.width/2, player.y + player.height, 120, 40);
                createParticles(player.x + player.width/2, player.y + player.height, 18, '#00aaff', 1.2);
            }
        }

        function checkBossDoorInteraction() {
            if (gameState.bossSpawned || gameState.bossActive) return;
            
            const player = gameState.player;
            let nearDoor = false;
            
            gameState.bossDoors.forEach(door => {
                if (player.x < door.x + door.width &&
                    player.x + player.width > door.x &&
                    player.y < door.y + door.height &&
                    player.y + player.height > door.y) {
                    
                    nearDoor = true;
                    gameState.bossDoorActive = true;
                    
                    const doorInteraction = document.getElementById('doorInteraction');
                    doorInteraction.style.display = 'block';
                    doorInteraction.style.left = `${door.x - gameState.camera.x + door.width/2}px`;
                    doorInteraction.style.top = `${door.y - gameState.camera.y - 50}px`;
                }
            });
            
            if (!nearDoor) {
                gameState.bossDoorActive = false;
                document.getElementById('doorInteraction').style.display = 'none';
            }
        }

        function activateBossDoor() {
            if (gameState.bossSpawned || gameState.bossActive) return;
            
            const level = levels[gameState.currentLevel - 1];
            const bossType = level.bossDoor.bossType;
            const bossConfig = bossTypes[bossType];
            
            gameState.currentBoss = {
                ...bossConfig,
                x: level.bossSpawn.x,
                y: level.bossSpawn.y - bossConfig.height,
                type: bossType,
                health: bossConfig.health,
                maxHealth: bossConfig.health,
                lastAttack: 0,
                specialAttackCooldown: 0,
                phase: 1,
                dashCharging: false,
                dashChargeTime: 0,
                dashCharged: false,
                lastDashTime: 0,
                chargedBeamCharging: false,
                chargedBeamChargeTime: 0,
                chargedBeamCharged: false,
                lastChargedBeamTime: 0
            };
            
            gameState.bossSpawned = true;
            gameState.bossActive = true;
            
            gameState.bossDoors = [];
            
            gameState.bossBarriers.forEach(barrier => {
                const index = gameState.platforms.indexOf(barrier);
                if (index !== -1) {
                    gameState.platforms.splice(index, 1);
                }
            });
            
            document.getElementById('enemyName').textContent = bossConfig.name;
            document.getElementById('enemyHealthContainer').style.display = 'flex';
            
            for (let i = 0; i < 60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 100;
                createParticles(
                    level.bossSpawn.x + Math.cos(angle) * distance,
                    level.bossSpawn.y + Math.sin(angle) * distance,
                    1,
                    bossConfig.color,
                    2
                );
            }
            
            createTextParticles(level.bossSpawn.x, level.bossSpawn.y, bossConfig.name + ' APARECEU!', '#ff0000');
            
            gameState.camera.shake = 50;
            gameState.camera.shakeIntensity = 20;
            
            document.getElementById('doorInteraction').style.display = 'none';
        }

        function collectPickup(pickup) {
            const player = gameState.player;
            
            switch (pickup.type) {
                case 'health':
                    player.health = Math.min(player.maxHealth, player.health + pickup.value);
                    createTextParticles(pickup.x + 12, pickup.y + 12, `+${pickup.value} HEALTH`, '#00ff00');
                    addStylePoints(5, 'HEALTH');
                    break;
                    
                case 'coin':
                    player.coins += pickup.value;
                    gameState.score += pickup.value;
                    createTextParticles(pickup.x + 12, pickup.y + 12, `+${pickup.value} COINS`, '#ff9900');
                    addStylePoints(10, 'COIN');
                    break;
            }
            
            createParticles(pickup.x + 12, pickup.y + 12, 12, '#ffffff', 1);
            updateUI();
        }

        function enemyKilled(enemy) {
            const points = enemy.points * gameState.styleMultiplier;
            gameState.score += points;
            
            addStylePoints(15, 'KILL');
            
            gameState.killCombo++;
            gameState.maxCombo = Math.max(gameState.maxCombo, gameState.killCombo);
            
            document.getElementById('comboCounter').textContent = `COMBO: ${gameState.killCombo}x`;
            document.getElementById('comboCounter').style.display = 'block';
            
            gameState.killCount++;
            
            createGoreEffect(enemy);
            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 15, enemy.color, 1);
            createTextParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, `+${points}`, '#ffff00');
            
            updateUI();
        }

        function bossKilled(boss) {
            const points = boss.points * gameState.styleMultiplier;
            gameState.score += points;
            
            addStylePoints(100, 'BOSS KILL');
            
            createGoreEffect(boss, true);
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 150;
                createParticles(
                    boss.x + boss.width/2 + Math.cos(angle) * distance,
                    boss.y + boss.height/2 + Math.sin(angle) * distance,
                    1,
                    boss.color,
                    2.5
                );
            }
            
            createTextParticles(boss.x + boss.width/2, boss.y + boss.height/2, `BOSS DEFEATED! +${points}`, '#ffff00');
            
            gameState.camera.shake = 60;
            gameState.camera.shakeIntensity = 25;
            
            gameState.currentBoss = null;
            gameState.bossActive = false;
            
            document.getElementById('enemyHealthContainer').style.display = 'none';
            document.getElementById('bossDashAura').style.display = 'none';
            document.getElementById('bossChargeEffect').style.display = 'none';
            
            const level = levels[gameState.currentLevel - 1];
            level.goal.active = true;
            
            updateUI();
        }

        function createGoreEffect(enemy, isBoss = false) {
            const chunkCount = isBoss ? enemy.goreChunks * 3 : enemy.goreChunks;
            const chunkSize = isBoss ? 10 : 5;
            
            for (let i = 0; i < chunkCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 12 + 6;
                const size = Math.random() * chunkSize + chunkSize/2;
                
                const goreTypes = [
                    { color: '#ff0000', type: 'flesh' },
                    { color: '#8b0000', type: 'dark_flesh' },
                    { color: '#ff5555', type: 'light_flesh' },
                    { color: '#ffffff', type: 'bone' }
                ];
                
                const goreType = goreTypes[Math.floor(Math.random() * goreTypes.length)];
                
                gameState.particles.push({
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y + enemy.height / 2,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: size,
                    color: goreType.color,
                    life: 100 + Math.random() * 50,
                    maxLife: 150,
                    isGore: true,
                    goreType: goreType.type,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1
                });
            }
            
            for (let i = 0; i < chunkCount * 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 10 + 4;
                const size = Math.random() * 4 + 1;
                
                gameState.particles.push({
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y + enemy.height / 2,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: size,
                    color: '#8b0000',
                    life: 60 + Math.random() * 30,
                    maxLife: 90,
                    isGore: true,
                    goreType: 'blood'
                });
            }
            
            for (let i = 0; i < 8; i++) {
                const sprayAngle = Math.random() * Math.PI * 2;
                const sprayLength = 80 + Math.random() * 120;
                
                for (let j = 0; j < 15; j++) {
                    const dist = j * sprayLength / 15;
                    gameState.particles.push({
                        x: enemy.x + enemy.width / 2 + Math.cos(sprayAngle) * dist,
                        y: enemy.y + enemy.height / 2 + Math.sin(sprayAngle) * dist,
                        dx: Math.cos(sprayAngle) * 4,
                        dy: Math.sin(sprayAngle) * 4,
                        size: Math.random() * 3 + 1,
                        color: '#ff0000',
                        life: 40 + Math.random() * 30,
                        maxLife: 70,
                        isGore: true,
                        goreType: 'blood_spray'
                    });
                }
            }
        }

        function showDamageIndicator() {
            const indicator = document.getElementById('damageIndicator');
            indicator.style.background = 'radial-gradient(circle, rgba(255,0,0,0.4) 0%, rgba(255,0,0,0) 70%)';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 400);
        }

        function checkLevelCompletion() {
            const player = gameState.player;
            const level = levels[gameState.currentLevel - 1];
            const goal = level.goal;
            
            if (!goal.active) return;
            
            if (player.x < goal.x + goal.width &&
                player.x + player.width > goal.x &&
                player.y < goal.y + goal.height &&
                player.y + player.height > goal.y &&
                gameState.enemies.length === 0) {
                
                levelComplete();
            }
        }

        function gameOver() {
            gameState.gameOver = true;
            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('finalScore').textContent = `SCORE: ${gameState.score}`;
            document.getElementById('finalStyle').textContent = `ESTILO M√ÅXIMO: ${gameState.styleRank}`;
            document.getElementById('killCount').textContent = `INIMIGOS ELIMINADOS: ${gameState.killCount}`;
            document.getElementById('maxCombo').textContent = `COMBO M√ÅXIMO: ${gameState.maxCombo}x`;
        }

        function levelComplete() {
            gameState.levelComplete = true;
            document.getElementById('levelCompleteScreen').style.display = 'flex';
            document.getElementById('levelScore').textContent = `SCORE: ${gameState.score}`;
            document.getElementById('styleAchieved').textContent = `ESTILO M√ÅXIMO: ${gameState.styleRank}`;
            document.getElementById('levelKills').textContent = `INIMIGOS ELIMINADOS: ${gameState.killCount}`;
            document.getElementById('levelCombo').textContent = `COMBO M√ÅXIMO: ${gameState.maxCombo}x`;
            
            const seconds = Math.floor(gameState.levelTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            document.getElementById('levelTime').textContent = `TEMPO: ${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function drawBackground() {
            const level = levels[gameState.currentLevel - 1];
            const bgConfig = backgroundTypes[level.background];
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, bgConfig.gradient.start);
            gradient.addColorStop(1, bgConfig.gradient.end);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const sortedBackgrounds = [...gameState.backgrounds].sort((a, b) => a.layer - b.layer);
            
            sortedBackgrounds.forEach(bg => {
                if (bg.type === 'mountain') {
                    const screenX = bg.x - gameState.camera.x * bg.layer;
                    if (screenX > -bg.width && screenX < canvas.width + bg.width) {
                        ctx.fillStyle = bg.color;
                        ctx.beginPath();
                        ctx.moveTo(screenX, bg.y);
                        ctx.lineTo(screenX + bg.width, bg.y);
                        ctx.lineTo(screenX + bg.width/2, bg.y - bg.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.fillRect(screenX + bg.width/4, bg.y - bg.height/2, bg.width/2, 1);
                    }
                } else if (bg.type === 'building') {
                    const screenX = bg.x - gameState.camera.x * bg.layer;
                    if (screenX > -bg.width && screenX < canvas.width + bg.width) {
                        ctx.fillStyle = bg.color;
                        ctx.fillRect(screenX, bg.y - bg.height, bg.width, bg.height);
                        
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        const windowRows = Math.floor(bg.height / 30);
                        const windowCols = Math.floor(bg.width / 20);
                        for (let i = 0; i < windowCols; i++) {
                            for (let j = 0; j < windowRows; j++) {
                                if (Math.random() > 0.5) {
                                    ctx.fillRect(
                                        screenX + 10 + i * 20,
                                        bg.y - bg.height + 15 + j * 30,
                                        10,
                                        20
                                    );
                                }
                            }
                        }
                    }
                } else if (bg.type === 'fog') {
                    ctx.fillStyle = bg.color;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            });
            
            gameState.backgroundParticles.forEach(particle => {
                const screenX = particle.x - gameState.camera.x * particle.layer;
                const screenY = particle.y - gameState.camera.y * particle.layer * 0.5;
                
                if (screenX > -20 && screenX < canvas.width + 20 && 
                    screenY > -20 && screenY < canvas.height + 20) {
                    
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = particle.color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, particle.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            if (bgConfig.lava) {
                ctx.fillStyle = bgConfig.lavaColor;
                ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                
                if (bgConfig.lavaGlow) {
                    const lavaGradient = ctx.createLinearGradient(0, canvas.height - 60, 0, canvas.height);
                    lavaGradient.addColorStop(0, bgConfig.lavaColor.replace(')', ', 0.8)').replace('rgb', 'rgba'));
                    lavaGradient.addColorStop(1, bgConfig.lavaColor.replace(')', ', 0.3)').replace('rgb', 'rgba'));
                    ctx.fillStyle = lavaGradient;
                    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                }
                
                ctx.fillStyle = bgConfig.lavaColor.replace(')', ', 0.6)').replace('rgb', 'rgba');
                for (let i = 0; i < canvas.width; i += 50) {
                    const waveHeight = Math.sin(Date.now() * 0.001 + i * 0.05) * 15;
                    ctx.beginPath();
                    ctx.ellipse(i + 25, canvas.height - 60 + waveHeight, 25, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            if (bgConfig.cathedral) {
                ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
                ctx.fillRect(canvas.width / 2 - 150, 0, 300, 150);
                
                if (bgConfig.stainedGlass) {
                    const glassGradient = ctx.createLinearGradient(canvas.width / 2 - 120, 0, canvas.width / 2 + 120, 0);
                    glassGradient.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
                    glassGradient.addColorStop(0.5, 'rgba(0, 0, 255, 0.4)');
                    glassGradient.addColorStop(1, 'rgba(255, 0, 0, 0.4)');
                    ctx.fillStyle = glassGradient;
                    ctx.fillRect(canvas.width / 2 - 120, 20, 240, 100);
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(canvas.width / 2 - 120 + i * 40, 20);
                        ctx.lineTo(canvas.width / 2 - 120 + i * 40, 120);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawPlatforms() {
            gameState.platforms.forEach(platform => {
                const screenX = platform.x - gameState.camera.x;
                const screenY = platform.y - gameState.camera.y;
                
                if (platform.type === 'ground') {
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#333';
                    for (let i = 0; i < platform.width; i += 60) {
                        ctx.fillRect(screenX + i, screenY, 30, platform.height);
                    }
                    
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < platform.width; i += 100) {
                        if (Math.random() > 0.5) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + i + Math.random() * 40, screenY);
                            ctx.lineTo(screenX + i + Math.random() * 40, screenY + platform.height);
                            ctx.stroke();
                        }
                    }
                } else if (platform.type === 'platform') {
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(screenX, screenY, platform.width, 6);
                    
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(screenX, screenY, 8, platform.height);
                    ctx.fillRect(screenX + platform.width - 8, screenY, 8, platform.height);
                } else if (platform.type === 'floating') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);
                } else if (platform.type === 'wall') {
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#444';
                    for (let i = 0; i < platform.height; i += 30) {
                        ctx.fillRect(screenX, screenY + i, platform.width, 15);
                    }
                    
                    ctx.fillStyle = '#555';
                    for (let i = 0; i < platform.height; i += 60) {
                        ctx.beginPath();
                        ctx.arc(screenX + platform.width/2, screenY + i + 15, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (platform.topSolid) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(screenX, screenY, platform.width, 5);
                    }
                } else if (platform.type === 'moving') {
                    ctx.fillStyle = '#4a3a00';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#6a5a00';
                    ctx.fillRect(screenX, screenY, platform.width, 4);
                    
                    ctx.fillStyle = '#333';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(screenX + platform.width/4 + i * platform.width/4, screenY + platform.height/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (platform.type === 'boss_arena') {
                    ctx.fillStyle = 'rgba(30, 0, 0, 0.9)';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    for (let i = 0; i < platform.width; i += 80) {
                        for (let j = 0; j < platform.height; j += 80) {
                            if ((i + j) % 160 === 0) {
                                ctx.fillRect(screenX + i, screenY + j, 40, 40);
                            }
                        }
                    }
                }
                
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(screenX, screenY, platform.width, platform.height);
            });
        }

        function drawObstacles() {
            gameState.obstacles.forEach(obstacle => {
                const screenX = obstacle.x - gameState.camera.x;
                const screenY = obstacle.y - gameState.camera.y;
                
                if (obstacle.type === 'spike') {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY + obstacle.height);
                    ctx.lineTo(screenX + obstacle.width/2, screenY);
                    ctx.lineTo(screenX + obstacle.width, screenY + obstacle.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#880000';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(screenX + obstacle.width/4 + i * obstacle.width/4, screenY + obstacle.height, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (obstacle.type === 'lava_pit' || obstacle.type === 'forge_fire' || obstacle.type === 'cathedral_trap') {
                    ctx.fillStyle = '#ff3300';
                    ctx.fillRect(screenX, screenY, obstacle.width, obstacle.height);
                    
                    const lavaGradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + obstacle.height);
                    lavaGradient.addColorStop(0, '#ff5500');
                    lavaGradient.addColorStop(1, '#ff1100');
                    ctx.fillStyle = lavaGradient;
                    ctx.fillRect(screenX, screenY, obstacle.width, obstacle.height);
                    
                    ctx.fillStyle = '#ff8800';
                    for (let i = 0; i < 4; i++) {
                        const bubbleX = screenX + Math.random() * obstacle.width;
                        const bubbleY = screenY + Math.random() * obstacle.height;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, 2 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        function drawDecorations() {
            gameState.decorations.forEach(decoration => {
                const screenX = decoration.x - gameState.camera.x;
                const screenY = decoration.y - gameState.camera.y;
                
                if (decoration.type === 'skull_pile') {
                    for (let i = 0; i < 3; i++) {
                        const skullX = screenX + i * 15;
                        const skullY = screenY + (i % 2) * 10;
                        
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(skullX + 10, skullY + 10, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(skullX + 7, skullY + 8, 1.5, 0, Math.PI * 2);
                        ctx.arc(skullX + 13, skullY + 8, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(skullX + 10, skullY + 14, 3, 0, Math.PI, false);
                        ctx.stroke();
                    }
                } else if (decoration.type === 'hell_pillar') {
                    ctx.fillStyle = '#3a2a2a';
                    ctx.fillRect(screenX, screenY, decoration.width, decoration.height);
                    
                    ctx.fillStyle = '#4a3a3a';
                    ctx.fillRect(screenX, screenY, decoration.width, 12);
                    ctx.fillRect(screenX, screenY + decoration.height - 12, decoration.width, 12);
                    
                    ctx.strokeStyle = '#2a1a1a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + 5 + i * 15, screenY + 12);
                        ctx.lineTo(screenX + 5 + i * 15, screenY + decoration.height - 12);
                        ctx.stroke();
                    }
                } else if (decoration.type === 'hell_statue') {
                    ctx.fillStyle = '#4a3a3a';
                    ctx.fillRect(screenX + 30, screenY, 40, decoration.height);
                    ctx.beginPath();
                    ctx.arc(screenX + 50, screenY - 20, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(screenX, screenY + 50, 30, 12);
                    ctx.fillRect(screenX + 70, screenY + 50, 30, 12);
                    ctx.beginPath();
                    ctx.moveTo(screenX + 35, screenY - 20);
                    ctx.lineTo(screenX + 25, screenY - 50);
                    ctx.lineTo(screenX + 35, screenY - 40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(screenX + 65, screenY - 20);
                    ctx.lineTo(screenX + 75, screenY - 50);
                    ctx.lineTo(screenX + 65, screenY - 40);
                    ctx.closePath();
                    ctx.fill();
                } else if (decoration.type === 'forge_anvil') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX, screenY + 20, decoration.width, 40);
                    ctx.fillRect(screenX + 10, screenY, decoration.width - 20, 25);
                    ctx.fillRect(screenX + 5, screenY + 10, 12, 8);
                    ctx.fillRect(screenX + decoration.width - 17, screenY + 10, 12, 8);
                } else if (decoration.type === 'forge_furnace') {
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(screenX, screenY, decoration.width, decoration.height);
                    
                    ctx.fillStyle = '#ff3300';
                    ctx.beginPath();
                    ctx.arc(screenX + decoration.width/2, screenY + decoration.height/2, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff5500';
                    ctx.beginPath();
                    ctx.arc(screenX + decoration.width/2, screenY + decoration.height/2, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
                    for (let i = 0; i < 3; i++) {
                        const smokeY = screenY - Math.sin(Date.now() * 0.001 + i) * 5;
                        ctx.beginPath();
                        ctx.arc(screenX + decoration.width/2, smokeY, 4 + i * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (decoration.type === 'forge_statue') {
                    ctx.fillStyle = '#5a4a4a';
                    ctx.fillRect(screenX + 20, screenY + 100, 60, 16);
                    ctx.fillRect(screenX + 30, screenY + 20, 40, 80);
                    ctx.beginPath();
                    ctx.arc(screenX + 50, screenY, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#3a2a2a';
                    ctx.fillRect(screenX + 60, screenY + 40, 25, 8);
                    ctx.fillRect(screenX + 85, screenY + 30, 12, 25);
                } else if (decoration.type === 'cathedral_statue') {
                    ctx.fillStyle = '#6a6a6a';
                    ctx.beginPath();
                    ctx.moveTo(screenX + 40, screenY + decoration.height);
                    ctx.lineTo(screenX, screenY + 60);
                    ctx.lineTo(screenX + decoration.width, screenY + 60);
                    ctx.lineTo(screenX + decoration.width - 40, screenY + decoration.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillRect(screenX + 30, screenY + 20, 20, 40);
                    ctx.beginPath();
                    ctx.arc(screenX + 40, screenY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8a8a8a';
                    ctx.beginPath();
                    ctx.moveTo(screenX + 20, screenY + 30);
                    ctx.lineTo(screenX - 20, screenY + 10);
                    ctx.lineTo(screenX, screenY + 40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(screenX + 60, screenY + 30);
                    ctx.lineTo(screenX + 100, screenY + 10);
                    ctx.lineTo(screenX + 80, screenY + 40);
                    ctx.closePath();
                    ctx.fill();
                } else if (decoration.type === 'cathedral_altar') {
                    ctx.fillStyle = '#4a2a2a';
                    ctx.fillRect(screenX, screenY, decoration.width, decoration.height);
                    
                    ctx.fillStyle = '#5a3a3a';
                    ctx.fillRect(screenX, screenY, decoration.width, 16);
                    
                    ctx.fillStyle = '#8a0000';
                    ctx.beginPath();
                    ctx.ellipse(screenX + decoration.width/2, screenY + 8, 16, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 3; i++) {
                        const candleX = screenX + 20 + i * 30;
                        ctx.fillRect(candleX, screenY + 25, 5, 25);
                        ctx.fillStyle = '#ff9900';
                        ctx.beginPath();
                        ctx.arc(candleX + 2.5, screenY + 20, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#fff';
                    }
                }
            });
        }

        function drawPickups() {
            gameState.pickups.forEach(pickup => {
                const y = pickup.y + (pickup.offsetY || 0);
                const screenX = pickup.x - gameState.camera.x;
                const screenY = y - gameState.camera.y;
                
                if (pickup.type === 'health') {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(screenX + 8, screenY, 4, 25);
                    ctx.fillRect(screenX, screenY + 8, 20, 4);
                } else if (pickup.type === 'coin') {
                    ctx.save();
                    ctx.translate(screenX + 12, screenY + 12);
                    ctx.rotate(pickup.rotation || 0);
                    
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff9900';
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff9900';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', 0, 0);
                    
                    ctx.restore();
                }
                
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(screenX, screenY, 25, 25);
            });
        }

        function drawBossDoor() {
            gameState.bossDoors.forEach(door => {
                const screenX = door.x - gameState.camera.x;
                const screenY = door.y - gameState.camera.y;
                
                ctx.fillStyle = '#4a2a2a';
                ctx.fillRect(screenX, screenY, door.width, door.height);
                
                ctx.fillStyle = '#2a1a1a';
                ctx.fillRect(screenX + 10, screenY + 10, door.width - 20, 12);
                ctx.fillRect(screenX + 10, screenY + door.height - 20, door.width - 20, 10);
                
                ctx.fillStyle = '#ffd700';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(screenX + door.width - 25, screenY + 30 + i * 40, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 60px Rajdhani';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ò†', screenX + door.width/2, screenY + door.height/2);
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.strokeRect(screenX, screenY, door.width, door.height);
                
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 4, screenY + 4, door.width - 8, door.height - 8);
                
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse * 0.3})`;
                ctx.fillRect(screenX, screenY, door.width, door.height);
            });
        }

        function drawPlayer() {
            const player = gameState.player;
            const screenX = player.x - gameState.camera.x;
            const screenY = player.y - gameState.camera.y;
            
            let playerColor = 'royalblue';
            if (player.isDashing) playerColor = '#00aaff';
            if (player.abilities.bloodRage.active) playerColor = '#ff0000';
            if (player.wallRunning) playerColor = '#00ff00';
            
            ctx.fillStyle = playerColor;
            ctx.fillRect(screenX + 10, screenY + 10, 30, 40);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(screenX + 15, screenY, 20, 12);
            
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(screenX + 25, screenY + 6, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(screenX + 25, screenY + 6, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333333';
            ctx.fillRect(screenX, screenY + 15, 10, 20);
            ctx.fillRect(screenX + 40, screenY + 15, 10, 20);
            
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.arc(screenX + 5, screenY + 25, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(screenX + 45, screenY + 25, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = playerColor;
            ctx.fillRect(screenX + 15, screenY + 50, 8, 20);
            ctx.fillRect(screenX + 27, screenY + 50, 8, 20);
            
            ctx.fillStyle = '#333333';
            ctx.fillRect(screenX + 13, screenY + 68, 12, 3);
            ctx.fillRect(screenX + 25, screenY + 68, 12, 3);
            
            ctx.fillStyle = playerColor;
            ctx.fillRect(screenX + 40, screenY + 20, 15, 6);
            
            const weapon = player.weapons[player.currentWeapon];
            ctx.fillStyle = weapon.color;
            
            if (weapon.name === 'Revolver') {
                ctx.fillRect(screenX + 55, screenY + 18, 18, 6);
                ctx.fillRect(screenX + 73, screenY + 20, 4, 3);
                ctx.fillStyle = '#333';
                ctx.beginPath();
                    ctx.arc(screenX + 60, screenY + 21, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (weapon.name === 'Shotgun') {
                ctx.fillRect(screenX + 55, screenY + 15, 22, 10);
                ctx.fillRect(screenX + 77, screenY + 18, 12, 4);
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX + 65, screenY + 12, 8, 2);
            } else if (weapon.name === 'Nailgun') {
                ctx.fillRect(screenX + 55, screenY + 20, 18, 5);
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(screenX + 50, screenY + 15, 4, 8);
                ctx.fillRect(screenX + 73, screenY + 21, 8, 3);
            } else if (weapon.name === 'Railgun') {
                ctx.fillRect(screenX + 55, screenY + 18, 25, 6);
                ctx.fillStyle = '#0066ff';
                ctx.beginPath();
                ctx.arc(screenX + 65, screenY + 21, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX + 80, screenY + 20, 8, 2);
            } else if (weapon.name === 'Rocket Launcher') {
                ctx.fillRect(screenX + 55, screenY + 15, 22, 10);
                ctx.fillStyle = '#ff5500';
                ctx.beginPath();
                ctx.arc(screenX + 68, screenY + 20, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX + 77, screenY + 18, 2, 5);
            }
            
            if (player.isDashing) {
                ctx.fillStyle = 'rgba(0, 170, 255, 0.2)';
                ctx.fillRect(screenX - 12, screenY - 8, player.width + 24, player.height + 16);
                
                for (let i = 0; i < 3; i++) {
                    const trailX = screenX - i * 8;
                    ctx.fillStyle = `rgba(0, 170, 255, ${0.1 - i * 0.03})`;
                    ctx.fillRect(trailX, screenY, player.width, player.height);
                }
            }
            
            if (player.abilities.bloodRage.active) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                ctx.fillRect(screenX - 8, screenY - 8, player.width + 16, player.height + 16);
                
                if (Math.random() < 0.3) {
                    createParticles(player.x + player.width/2, player.y + player.height/2, 1, '#ff0000', 0.6);
                }
            }
            
            if (player.wallRunning) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                ctx.fillRect(screenX - 4, screenY - 4, player.width + 8, player.height + 8);
            }
            
            if (player.punchCooldown > 0) {
                const punchRadius = player.punchRange * (player.punchCooldown / player.maxPunchCooldown);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(screenX + player.width/2, screenY + player.height/2, punchRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawEnemies() {
            gameState.enemies.forEach(enemy => {
                const screenX = enemy.x - gameState.camera.x;
                const screenY = enemy.y - gameState.camera.y;
                
                const enemyKey = `${enemy.x}-${enemy.y}`;
                const hitCooldown = gameState.enemyHitCooldowns.get(enemyKey) || 0;
                
                if (Date.now() - hitCooldown < 1000) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(screenX, screenY, enemy.width, enemy.height);
                }
                
                switch (enemy.design) {
                    case 'husk':
    // Corpo principal - estilo Filth do Ultrakill
    ctx.fillStyle = '#6B8E23';
    ctx.beginPath();
    ctx.roundRect(screenX + 10, screenY + 15, 30, 35, 5);
    ctx.fill();
    
    // Cabe√ßa
    ctx.fillStyle = '#6B8E23';
    ctx.beginPath();
    ctx.arc(screenX + 25, screenY + 10, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Boca
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(screenX + 25, screenY + 15, 5, 0, Math.PI, false);
    ctx.stroke();
    
    // Dentes afiados
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(screenX + 20 + i * 3, screenY + 15);
        ctx.lineTo(screenX + 21 + i * 3, screenY + 20);
        ctx.lineTo(screenX + 22 + i * 3, screenY + 15);
        ctx.closePath();
        ctx.fill();
    }
    
    // Pernas
    ctx.fillStyle = '#6B8E23';
    for (let i = 0; i < 2; i++) {
        ctx.fillRect(screenX + 15 + i * 8, screenY + 50, 4, 10);
    }
    break;
                        
                   case 'soldier':
    // Corpo principal - estilo Soldier do Ultrakill
    ctx.fillStyle = '#FFFAFA';
    ctx.fillRect(screenX + 5, screenY + 20, 50, 45);
    
    // Capacete
    ctx.fillStyle = '#FFFAFA';
    ctx.fillRect(screenX, screenY, 60, 25);
    
    // Visor
    ctx.fillStyle = '#0000FF';
    ctx.fillRect(screenX + 15, screenY + 5, 30, 8);
    
    
    
   
    
    // Arma
    ctx.fillStyle = '#0000FF';
    ctx.fillRect(screenX + 60, screenY + 30, 15, 6);
    
    // Detalhes met√°licos
    ctx.fillStyle = '#0000FF';
    ctx.fillRect(screenX, screenY, 60, 3);
    ctx.fillRect(screenX, screenY + 22, 60, 3);
    ctx.fillRect(screenX, screenY + 63, 60, 2);
    
    // Pernas
    for (let i = 0; i < 2; i++) {
        ctx.fillStyle = '#0000FF';
        ctx.fillRect(screenX + 10 + i * 25, screenY + 65, 12, 15);
    }
    break;
                        
                    case 'machine':
    // Corpo principal circular - estilo Drone do Ultrakill
    ctx.fillStyle = '#A020F0';
    ctx.beginPath();
    ctx.arc(screenX + 35, screenY + 35, 30, 0, Math.PI * 2);
    ctx.fill();
    
    // Anel interno
    ctx.fillStyle = '#222222';
    ctx.beginPath();
    ctx.arc(screenX + 35, screenY + 35, 20, 0, Math.PI * 2);
    ctx.fill();
    
    // Olho central
    ctx.fillStyle = '#ff00ff';
    ctx.beginPath();
    ctx.arc(screenX + 35, screenY + 35, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Pupila
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(screenX + 35, screenY + 35, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Part√≠culas orbitantes (propulsores)
    const time = Date.now() * 0.01;
    for (let i = 0; i < 4; i++) {
        const angle = time + i * Math.PI/2;
        const x = screenX + 35 + Math.cos(angle) * 25;
        const y = screenY + 35 + Math.sin(angle) * 25;
        
        // Propulsor
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Brilho do propulsor
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Raios de energia
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
        const rayAngle = i * Math.PI/4 + time * 0.5;
        const rayLength = 15 + Math.sin(time + i) * 5;
        ctx.beginPath();
        ctx.moveTo(screenX + 35, screenY + 35);
        ctx.lineTo(
            screenX + 35 + Math.cos(rayAngle) * rayLength,
            screenY + 35 + Math.sin(rayAngle) * rayLength
        );
        ctx.stroke();
    }
    break;
                }
                
                const healthPercent = enemy.health / enemy.maxHealth;
                const barWidth = enemy.width + 20;
                const barHeight = 6;
                const barX = screenX - 10;
                const barY = screenY - 12;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                if (healthPercent > 0.6) {
                    ctx.fillStyle = '#00ff00';
                } else if (healthPercent > 0.3) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            });
        }

        function drawBoss() {
            if (!gameState.currentBoss || !gameState.bossActive) return;
            
            const boss = gameState.currentBoss;
            const screenX = boss.x - gameState.camera.x;
            const screenY = boss.y - gameState.camera.y;
            
            const bossKey = `boss-${boss.type}`;
            const hitCooldown = gameState.enemyHitCooldowns.get(bossKey) || 0;
            
            if (Date.now() - hitCooldown < 1000) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(screenX, screenY, boss.width, boss.height);
            }
            
            switch (boss.design) {
                case 'cerberus':
                     ctx.fillStyle = '#DAA520'; // Cor de pedra
                        ctx.beginPath();
                        ctx.roundRect(screenX + 20, screenY + 60, 160, 140, 20);
                        ctx.fill();

                        // Detalhes de pedra (rachaduras)
                        ctx.strokeStyle = '#6B5B45';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        // Rachaduras horizontais
                        for (let i = 0; i < 3; i++) {
                            const crackY = screenY + 80 + i * 40;
                            ctx.moveTo(screenX + 30, crackY);
                            ctx.lineTo(screenX + 170, crackY);
                        }
                        // Rachaduras verticais
                        for (let i = 0; i < 4; i++) {
                            const crackX = screenX + 40 + i * 40;
                            ctx.moveTo(crackX, screenY + 70);
                            ctx.lineTo(crackX, screenY + 190);
                        }
                        ctx.stroke();

                        // M√öSCULOS EM RELEVO - Textura muscular
                        ctx.fillStyle = '#6B5B45';

                        // Grupos musculares do torso
                        for (let i = 0; i < 6; i++) {
                            const muscleX = screenX + 40 + i * 25;
                            const muscleY = screenY + 80;
                            const muscleWidth = 15;
                            const muscleHeight = 100;

                            // M√∫sculo principal
                            ctx.beginPath();
                            ctx.roundRect(muscleX, muscleY, muscleWidth, muscleHeight, 10);
                            ctx.fill();

                            // Detalhes do m√∫sculo (linhas de defini√ß√£o)
                            ctx.strokeStyle = '#5B4B35';
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(muscleX + muscleWidth/2, muscleY);
                            ctx.lineTo(muscleX + muscleWidth/2, muscleY + muscleHeight);
                            ctx.stroke();

                            // Sombra para efeito 3D
                            const gradient = ctx.createLinearGradient(
                                muscleX, muscleY,
                                muscleX + muscleWidth, muscleY
                            );
                            gradient.addColorStop(0, 'rgba(0,0,0,0.3)');
                            gradient.addColorStop(1, 'transparent');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(muscleX, muscleY, muscleWidth, muscleHeight);
                        }

                        
                        for (let i = 0; i < 1; i++) {
                            const headX = screenX + 95 + i * 40;
                            const headY = screenY + 30;
                            const headRadius = 28;

                            // Cabe√ßa de pedra
                            ctx.fillStyle = '#DAA520';
                            ctx.beginPath();
                            ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Detalhes de pedra na cabe√ßa
                            ctx.strokeStyle = '#6B5B45';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            // Rachaduras na cabe√ßa
                            ctx.arc(headX, headY, headRadius - 5, 0, Math.PI * 2);
                            ctx.stroke();

                        for (let i = 0; i < 2; i++) {
                            const legX = screenX + 30 + i * 50;
                            const legY = screenY + 225;

                            // Perna
                            ctx.fillStyle = '#DAA520';
                            ctx.fillRect(legX, legY, 20, 30);

                            // Articula√ß√£o
                            ctx.fillStyle = '#6B5B45';
                            ctx.beginPath();
                            ctx.arc(legX + 10, legY, 12, 0, Math.PI * 2);
                            ctx.fill();


                            }
                        }

                        // RASTEJOS DE ENERGIA (quando carregando dash)
                        if (boss.chargeBeamCharging) {
                            const chargePercent = boss.chargeBeamTime / boss.chargeBeamDuration;
                            const energyColor = `rgba(255, ${Math.floor(100 * chargePercent)}, 0, ${0.3 + chargePercent * 0.4})`;

                            ctx.strokeStyle = energyColor;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(screenX + 100, screenY + 130, 80 + chargePercent * 50, 0, Math.PI * 2);
                            ctx.stroke();

                            // Part√≠culas de energia
                            for (let i = 0; i < 8; i++) {
                                const energyAngle = Date.now() * 0.01 + i * Math.PI/4;
                                const energyRadius = 60 + chargePercent * 40;
                                const energyX = screenX + 100 + Math.cos(energyAngle) * energyRadius;
                                const energyY = screenY + 130 + Math.sin(energyAngle) * energyRadius;

                                ctx.fillStyle = `rgba(255, ${Math.floor(150 * chargePercent)}, 0, ${0.5 + chargePercent * 0.3})`;
                                ctx.beginPath();
                                ctx.arc(energyX, energyY, 3 + chargePercent * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }

                        // AURA DE DASH (quando dashing)
                        if (boss.dashCharged) {
                            const pulse = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
                            ctx.strokeStyle = `rgba(255, 50, 0, ${pulse})`;
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.arc(screenX + 100, screenY + 130, 100, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    break;
                    
                case 'forge_demon':
                    ctx.fillStyle = boss.color;
                    ctx.beginPath();
                    ctx.roundRect(screenX + 10, screenY + 40, boss.bodyWidth, boss.bodyHeight, 12);
                    ctx.fill();
                    
                    ctx.fillStyle = '#663300';
                    ctx.fillRect(screenX + boss.width - 10, screenY + 30, boss.hammerWidth, boss.hammerHeight);
                    
                    ctx.fillStyle = '#aa0000';
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2, screenY + 20, 30, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff5500';
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2 - 12, screenY + 15, 10, 0, Math.PI * 2);
                    ctx.arc(screenX + boss.width/2 + 12, screenY + 15, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff3300';
                    for (let i = 0; i < 6; i++) {
                        const flameX = screenX + 15 + i * 25;
                        ctx.beginPath();
                        ctx.moveTo(flameX, screenY);
                        ctx.lineTo(flameX + 12, screenY - 20);
                        ctx.lineTo(flameX + 24, screenY);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;
                    
                case 'archdemon':
                    ctx.fillStyle = boss.color;
                    ctx.beginPath();
                    ctx.roundRect(screenX + 10, screenY + boss.crownHeight, boss.bodyWidth, boss.bodyHeight, 12);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(screenX, screenY, boss.width, boss.crownHeight);
                    for (let i = 0; i < 5; i++) {
                        const spikeWidth = boss.width / 5;
                        const spikeX = screenX + i * spikeWidth;
                        ctx.beginPath();
                        ctx.moveTo(spikeX + spikeWidth/2, screenY);
                        ctx.lineTo(spikeX, screenY - 15);
                        ctx.lineTo(spikeX + spikeWidth, screenY - 15);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2, screenY + 40, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2 - 10, screenY + 35, boss.eyeRadius, 0, Math.PI * 2);
                    ctx.arc(screenX + boss.width/2 + 10, screenY + 35, boss.eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2 - 10, screenY + 35, boss.eyeRadius/2, 0, Math.PI * 2);
                    ctx.arc(screenX + boss.width/2 + 10, screenY + 35, boss.eyeRadius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX + boss.width/2, screenY + 55, 15, 0, Math.PI, false);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#550000';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY + 60);
                    ctx.lineTo(screenX - 60, screenY + 30);
                    ctx.lineTo(screenX - 40, screenY + 90);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(screenX + boss.width, screenY + 60);
                    ctx.lineTo(screenX + boss.width + 60, screenY + 30);
                    ctx.lineTo(screenX + boss.width + 40, screenY + 90);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#330000';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(screenX + 15, screenY + 80 + i * 25, boss.bodyWidth - 10, 4);
                    }
                    break;
            }
        }

        function drawBullets() {
            gameState.bullets.forEach(bullet => {
                const screenX = bullet.x - gameState.camera.x;
                const screenY = bullet.y - gameState.camera.y;
                
                if (bullet.beam) {
                    const endX = screenX + Math.cos(bullet.angle) * bullet.length;
                    const endY = screenY + Math.sin(bullet.angle) * bullet.length;
                    
                    ctx.strokeStyle = bullet.color;
                    ctx.lineWidth = bullet.width;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    ctx.strokeStyle = bullet.color.replace(')', ', 0.5)').replace('rgb', 'rgba');
                    ctx.lineWidth = bullet.width * 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    return;
                }
                
                if (bullet.vortex) {
                    ctx.strokeStyle = bullet.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = Date.now() * 0.001 + i * Math.PI/4;
                        const vortexX = screenX + Math.cos(angle) * bullet.radius;
                        const vortexY = screenY + Math.sin(angle) * bullet.radius;
                        ctx.fillStyle = bullet.color;
                        ctx.beginPath();
                        ctx.arc(vortexX, vortexY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    return;
                }
                
                if (bullet.lightning) {
                    const endX = screenX + Math.cos(bullet.angle) * bullet.length;
                    const endY = screenY + Math.sin(bullet.angle) * bullet.length;
                    
                    ctx.strokeStyle = bullet.color;
                    ctx.lineWidth = bullet.width;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    for (let i = 0; i < 3; i++) {
                        const offset = (Math.random() - 0.5) * 10;
                        const offsetAngle = bullet.angle + Math.PI/2;
                        const sparkX = screenX + Math.cos(offsetAngle) * offset;
                        const sparkY = screenY + Math.sin(offsetAngle) * offset;
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    return;
                }
                
                if (bullet.weaponType === 'Revolver') {
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(screenX + bullet.dx * bullet.radius, screenY + bullet.dy * bullet.radius, bullet.radius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 0.8;
                    for (let i = 0; i < 3; i++) {
                        const angle = Date.now() * 0.01 + i * Math.PI * 2/3;
                        const length = bullet.radius * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX + Math.cos(angle) * length, screenY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                } else if (bullet.weaponType === 'Shotgun') {
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff3300';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = bullet.color;
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(screenX - bullet.dx * 6, screenY - bullet.dy * 6);
                    ctx.lineTo(screenX, screenY);
                    ctx.stroke();
                } else if (bullet.weaponType === 'Nailgun') {
                    if (bullet.horizontal) {
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(screenX - 8, screenY - 3, 16, 6);
                        ctx.fillStyle = '#0066ff';
                        ctx.fillRect(screenX - 10, screenY - 5, 4, 10);
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.moveTo(screenX + 8, screenY);
                        ctx.lineTo(screenX + 12, screenY - 4);
                        ctx.lineTo(screenX + 12, screenY + 4);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(screenX - 2.5, screenY - 6, 5, 12);
                        ctx.fillStyle = '#0066ff';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY - 8, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + 6);
                        ctx.lineTo(screenX - 2.5, screenY + 10);
                        ctx.lineTo(screenX + 2.5, screenY + 10);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    if (bullet.orbiting) {
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 0.8;
                        const angle = Date.now() * 0.02;
                        const length = 5 + Math.sin(angle) * 2.5;
                        for (let i = 0; i < 4; i++) {
                            const sparkAngle = angle + i * Math.PI/2;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(screenX + Math.cos(sparkAngle) * length, screenY + Math.sin(sparkAngle) * length);
                            ctx.stroke();
                        }
                    }
                } else if (bullet.weaponType === 'Railgun') {
                    const time = Date.now() * 0.01;
    
    // N√∫cleo principal com gradiente
    const railGradient = ctx.createRadialGradient(
        screenX, screenY, 0,
        screenX, screenY, bullet.radius * 2
    );
    railGradient.addColorStop(0, '#0066ff');
    railGradient.addColorStop(0.3, '#0044aa');
    railGradient.addColorStop(1, '#002266');
    ctx.fillStyle = railGradient;
    ctx.beginPath();
    ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // N√∫cleo interno brilhante
    ctx.fillStyle = '#00aaff';
    ctx.beginPath();
    ctx.arc(screenX, screenY, bullet.radius * 0.4, 0, Math.PI * 2);
    ctx.fill();
    
    // *** NOVO: RAIOS DE ENERGIA AO REDOR ***
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1;
    for (let i = 0; i < 16; i++) {
        const lightningTime = time + i * 0.3;
        const lightningAngle = lightningTime;
        const lightningLength = bullet.radius * 2 + Math.sin(lightningTime * 2) * 10;
        
        // Raio principal
        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(
            screenX + Math.cos(lightningAngle) * lightningLength,
            screenY + Math.sin(lightningAngle) * lightningLength
        );
        ctx.stroke();
        
        // Ramos do raio
        for (let j = 0; j < 3; j++) {
            const branchTime = lightningTime + j * 0.5;
            const branchAngle = lightningAngle + (Math.sin(branchTime) * 0.5);
            const branchLength = lightningLength * 0.6;
            
            ctx.beginPath();
            const midX = screenX + Math.cos(lightningAngle) * (lightningLength * 0.5);
            const midY = screenY + Math.sin(lightningAngle) * (lightningLength * 0.5);
            ctx.moveTo(midX, midY);
            ctx.lineTo(
                midX + Math.cos(branchAngle) * branchLength,
                midY + Math.sin(branchAngle) * branchLength
            );
            ctx.stroke();
        }
    }
    
    // Efeito de choque
    if (bullet.shockwave) {
        ctx.strokeStyle = 'rgba(0, 170, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(screenX, screenY, bullet.radius * 1.5 + Math.sin(time) * 8, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Estrelas de energia
    ctx.fillStyle = '#00ffff';
    for (let i = 0; i < 8; i++) {
        const starAngle = time + i * Math.PI/4;
        const starRadius = bullet.radius * (1.2 + Math.sin(time + i) * 0.4);
        const starX = screenX + Math.cos(starAngle) * starRadius;
        const starY = screenY + Math.sin(starAngle) * starRadius;
        
        // Estrela de 5 pontas
        ctx.beginPath();
        for (let j = 0; j < 5; j++) {
            const angle = starAngle + j * Math.PI/2.5;
            const radius = j % 2 === 0 ? 3 : 6;
            const x = starX + Math.cos(angle) * radius;
            const y = starY + Math.sin(angle) * radius;
            
            if (j === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
    }
    
    // Rastro energ√©tico
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(screenX - bullet.dx * 30, screenY - bullet.dy * 30);
    ctx.lineTo(screenX, screenY);
    ctx.stroke();
    
    // Multiplos rastros
    for (let i = 0; i < 3; i++) {
        const trailX = screenX - bullet.dx * (i * 12);
        const trailY = screenY - bullet.dy * (i * 12);
        const trailSize = bullet.radius * (0.8 - i * 0.2);
        
        const trailGradient = ctx.createRadialGradient(
            trailX, trailY, 0,
            trailX, trailY, trailSize * 2
        );
        trailGradient.addColorStop(0, `rgba(0, 170, 255, ${0.7 - i * 0.2})`);
        trailGradient.addColorStop(1, `rgba(0, 170, 255, 0)`);
        
        ctx.fillStyle = trailGradient;
        ctx.beginPath();
        ctx.arc(trailX, trailY, trailSize * 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Part√≠culas de energia
    for (let i = 0; i < 4; i++) {
        const particleAngle = time + i * Math.PI/2;
        const particleDist = bullet.radius * 1.8;
        const particleX = screenX + Math.cos(particleAngle) * particleDist;
        const particleY = screenY + Math.sin(particleAngle) * particleDist;
        
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
        ctx.fill();
    }

                } else if (bullet.weaponType === 'Rocket Launcher') {
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.roundRect(screenX - 6, screenY - 4.5, 12, 9, 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff5500';
                    ctx.beginPath();
                    ctx.arc(screenX + 6, screenY, 4.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff3300';
                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI/2;
                        const finLength = 8;
                        ctx.beginPath();
                        ctx.moveTo(screenX - 6, screenY);
                        ctx.lineTo(screenX - 6 - Math.cos(angle) * finLength, screenY - Math.sin(angle) * finLength);
                        ctx.lineTo(screenX - 6 - Math.cos(angle + 0.5) * 4, screenY - Math.sin(angle + 0.5) * 4);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    const rocketLauncher = gameState.player.weapons[4];
                    if (!rocketLauncher.frozenRockets || !rocketLauncher.freezeActive) {
                        const engineGradient = ctx.createRadialGradient(screenX - 8, screenY, 0, screenX - 8, screenY, 8);
                        engineGradient.addColorStop(0, '#ff8800');
                        engineGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = engineGradient;
                        ctx.beginPath();
                        ctx.arc(screenX - 8, screenY, 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.strokeStyle = '#00aaff';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, bullet.radius * 2, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#00aaff';
                        for (let i = 0; i < 4; i++) {
                            const crystalAngle = i * Math.PI/2 + Date.now() * 0.001;
                            const crystalX = screenX + Math.cos(crystalAngle) * bullet.radius * 1.5;
                            const crystalY = screenY + Math.sin(crystalAngle) * bullet.radius * 1.5;
                            ctx.beginPath();
                            ctx.arc(crystalX, crystalY, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else {
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (bullet.isSpecial) {
                    const specialGlow = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, bullet.radius * 3);
                    specialGlow.addColorStop(0, bullet.color.replace(')', ', 0.8)').replace('rgb', 'rgba'));
                    specialGlow.addColorStop(1, bullet.color.replace(')', ', 0)').replace('rgb', 'rgba'));
                    ctx.fillStyle = specialGlow;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.radius * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            gameState.magnetNails.forEach(nail => {
                const screenX = nail.x - gameState.camera.x;
                const screenY = nail.y - gameState.camera.y;
                
                ctx.fillStyle = nail.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, nail.radius, 0, Math.PI * 2);
                ctx.fill();
                
                const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                
                ctx.strokeStyle = `rgba(0, 102, 255, ${pulse * 0.2})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 200, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(0, 102, 255, ${pulse * 0.4})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 80, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = `rgba(0, 102, 255, ${pulse})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, nail.radius * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 102, 255, ${pulse * 0.3})`;
                ctx.lineWidth = 0.8;
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI/4 + Date.now() * 0.001;
                    const startX = screenX + Math.cos(angle) * 25;
                    const startY = screenY + Math.sin(angle) * 25;
                    const endX = screenX + Math.cos(angle) * 50;
                    const endY = screenY + Math.sin(angle) * 50;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                const screenX = particle.x - gameState.camera.x;
                const screenY = particle.y - gameState.camera.y;
                const alpha = particle.life / particle.maxLife;
                
                if (particle.isGore) {
                    if (particle.goreType === 'flesh' || particle.goreType === 'dark_flesh' || particle.goreType === 'light_flesh') {
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.rotate(particle.rotation);
                        
                        ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const radius = particle.size * (0.7 + Math.sin(angle * 2) * 0.3);
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = particle.goreType === 'dark_flesh' ? 
                            'rgba(100, 0, 0, 0.3)' : 'rgba(200, 100, 100, 0.2)';
                        ctx.beginPath();
                        ctx.arc(0, 0, particle.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    } else if (particle.goreType === 'bone') {
                        ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        
                        ctx.ellipse(screenX, screenY, particle.size, particle.size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(240, 240, 240, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(screenX, screenY, particle.size * 0.7, particle.size * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.goreType === 'blood' || particle.goreType === 'blood_spray') {
                        ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (particle.goreType === 'blood_spray' && Math.random() > 0.7) {
                            ctx.fillStyle = particle.color.replace(')', `, ${alpha * 0.5})`).replace('rgb', 'rgba');
                            ctx.beginPath();
                            ctx.ellipse(screenX, screenY + particle.size, particle.size * 0.5, particle.size * 2, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else if (particle.text) {
                    ctx.font = `bold ${particle.size}px Rajdhani`;
                    ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(particle.text, screenX, screenY);
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                    ctx.fillText(particle.text, screenX + 1, screenY + 1);
                } else {
                    ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (particle.size > 1.5) {
                        ctx.fillStyle = particle.color.replace(')', `, ${alpha * 0.3})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, particle.size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        function drawShockwaves() {
            gameState.shockwaves.forEach(shockwave => {
                const screenX = shockwave.x - gameState.camera.x;
                const screenY = shockwave.y - gameState.camera.y;
                const alpha = 1 - (shockwave.radius / shockwave.maxRadius);
                
                ctx.strokeStyle = `rgba(0, 170, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, shockwave.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.arc(screenX, screenY, shockwave.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function drawGoal() {
            const level = levels[gameState.currentLevel - 1];
            const goal = level.goal;
            
            if (!goal.active) return;
            
            const screenX = goal.x - gameState.camera.x;
            const screenY = goal.y - gameState.camera.y;
            
            if (goal.type === 'core') {
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                
                const outerGlow = ctx.createRadialGradient(
                    screenX + goal.width/2, screenY + goal.height/2, 0,
                    screenX + goal.width/2, screenY + goal.height/2, goal.width
                );
                outerGlow.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                outerGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(screenX + goal.width/2, screenY + goal.height/2, goal.width, 0, Math.PI * 2);
                ctx.fill();
                
                const coreGradient = ctx.createRadialGradient(
                    screenX + goal.width/2, screenY + goal.height/2, 0,
                    screenX + goal.width/2, screenY + goal.height/2, goal.width/2
                );
                coreGradient.addColorStop(0, '#ff0000');
                coreGradient.addColorStop(0.7, '#aa0000');
                coreGradient.addColorStop(1, '#550000');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(screenX + goal.width/2, screenY + goal.height/2, goal.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                ctx.beginPath();
                ctx.arc(screenX + goal.width/2, screenY + goal.height/2, goal.width/4 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255, 255, 0, ${pulse})`;
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + Date.now() * 0.001;
                    const length = 25 + Math.sin(Date.now() * 0.003 + i) * 12;
                    ctx.beginPath();
                    ctx.moveTo(
                        screenX + goal.width/2 + Math.cos(angle) * goal.width/2,
                        screenY + goal.height/2 + Math.sin(angle) * goal.height/2
                    );
                    ctx.lineTo(
                        screenX + goal.width/2 + Math.cos(angle) * (goal.width/2 + length),
                        screenY + goal.height/2 + Math.sin(angle) * (goal.height/2 + length)
                    );
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 0.8;
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const length = goal.width/3 + Math.random() * goal.width/3;
                    ctx.beginPath();
                    ctx.moveTo(screenX + goal.width/2, screenY + goal.height/2);
                    ctx.lineTo(
                        screenX + goal.width/2 + Math.cos(angle) * length,
                        screenY + goal.height/2 + Math.sin(angle) * length
                    );
                    ctx.stroke();
                }
                
                for (let i = 0; i < 6; i++) {
                    const particleAngle = Date.now() * 0.001 + i * Math.PI/3;
                    const distance = goal.width + 15;
                    const particleX = screenX + goal.width/2 + Math.cos(particleAngle) * distance;
                    const particleY = screenY + goal.height/2 + Math.sin(particleAngle) * distance;
                    
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawUI() {
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = `${gameState.mouse.x}px`;
            crosshair.style.top = `${gameState.mouse.y}px`;
            
            const crosshairLines = document.querySelectorAll('.crosshair-line');
            const crosshairDot = document.querySelector('.crosshair-dot');
            let crosshairColor = '#ffffff';
            
            let aimingAtEnemy = false;
            gameState.enemies.forEach(enemy => {
                const enemyScreenX = enemy.x - gameState.camera.x + enemy.width/2;
                const enemyScreenY = enemy.y - gameState.camera.y + enemy.height/2;
                const distance = Math.sqrt(
                    Math.pow(gameState.mouse.x - enemyScreenX, 2) + 
                    Math.pow(gameState.mouse.y - enemyScreenY, 2)
                );
                
                if (distance < 50) {
                    aimingAtEnemy = true;
                }
            });
            
            if (gameState.currentBoss) {
                const boss = gameState.currentBoss;
                const bossScreenX = boss.x - gameState.camera.x + boss.width/2;
                const bossScreenY = boss.y - gameState.camera.y + boss.height/2;
                const distance = Math.sqrt(
                    Math.pow(gameState.mouse.x - bossScreenX, 2) + 
                    Math.pow(gameState.mouse.y - bossScreenY, 2)
                );
                
                if (distance < 80) {
                    aimingAtEnemy = true;
                }
            }
            
            if (aimingAtEnemy) {
                crosshairColor = '#ff0000';
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                crosshair.style.transform = `translate(-50%, -50%) scale(${1 + pulse * 0.1})`;
            } else {
                crosshair.style.transform = 'translate(-50%, -50%)';
            }
            
            crosshairLines.forEach(line => {
                line.style.backgroundColor = crosshairColor;
            });
            crosshairDot.style.backgroundColor = crosshairColor;
        }

        function updateUI() {
            const player = gameState.player;
            const weapon = player.weapons[player.currentWeapon];
            
            const healthPercent = player.health / player.maxHealth;
            document.getElementById('healthFill').style.width = `${healthPercent * 100}%`;
            document.getElementById('healthText').textContent = `HEALTH: ${Math.ceil(player.health)}`;
            
            if (healthPercent > 0.6) {
                document.getElementById('healthFill').style.background = 'linear-gradient(90deg, #00ff00 0%, #aaff00 50%, #ffff00 100%)';
            } else if (healthPercent > 0.3) {
                document.getElementById('healthFill').style.background = 'linear-gradient(90deg, #ffff00 0%, #ffaa00 50%, #ff8800 100%)';
            } else {
                document.getElementById('healthFill').style.background = 'linear-gradient(90deg, #ff8800 0%, #ff5500 50%, #ff0000 100%)';
            }
            
            document.getElementById('scoreDisplay').textContent = `SCORE: ${gameState.score}`;
            
            document.getElementById('weaponName').textContent = weapon.name.toUpperCase();
            
            if (weapon.cooldown > 0) {
                document.getElementById('weaponCooldown').textContent = `COOLDOWN: ${(weapon.cooldown/60).toFixed(1)}s`;
            } else if (weapon.name === 'Nailgun' && weapon.overheatCooldown > 0) {
                document.getElementById('weaponCooldown').textContent = `OVERHEAT: ${(weapon.overheatCooldown/60).toFixed(1)}s`;
            } else {
                document.getElementById('weaponCooldown').textContent = 'READY';
            }
            
            if (weapon.special) {
                if (weapon.name === 'Revolver') {
                    if (weapon.specialCooldown > 0) {
                        document.getElementById('weaponSpecial').textContent = `SPECIAL: COOLDOWN ${(weapon.specialCooldown/60).toFixed(1)}s`;
                    } else {
                        document.getElementById('weaponSpecial').textContent = 'SPECIAL: HOLD RIGHT CLICK';
                    }
                } else {
                    if (weapon.specialCooldown > 0) {
                        document.getElementById('weaponSpecial').textContent = `SPECIAL: ${weapon.special} (${(weapon.specialCooldown/60).toFixed(1)}s)`;
                    } else {
                        document.getElementById('weaponSpecial').textContent = `SPECIAL: ${weapon.special} (READY)`;
                    }
                }
            } else {
                document.getElementById('weaponSpecial').textContent = '';
            }
            
            const stylePercent = Math.min(100, gameState.stylePoints / 3);
            document.getElementById('styleFill').style.width = `${stylePercent}%`;
            
            if (gameState.killCombo > 0) {
                document.getElementById('comboCounter').textContent = `COMBO: ${gameState.killCombo}x`;
            }
        }

        function createParticles(x, y, count, color, sizeMultiplier = 0.8) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1.5;
                
                gameState.particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: Math.random() * 2 * sizeMultiplier + 0.5,
                    color: color,
                    life: 20 + Math.random() * 10,
                    maxLife: 30
                });
            }
        }

        function createTextParticles(x, y, text, color) {
            gameState.particles.push({
                x: x,
                y: y,
                dx: (Math.random() - 0.5) * 2,
                dy: -2 - Math.random() * 1.5,
                size: 14,
                color: color,
                life: 60,
                maxLife: 60,
                text: text
            });
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            loadLevel(gameState.currentLevel - 1);
        }

        function nextLevel() {
            document.getElementById('levelCompleteScreen').style.display = 'none';
            gameState.currentLevel++;
            
            if (gameState.currentLevel > levels.length) {
                alert(`PARAB√âNS! VOC√ä COMPLETOU TODOS OS N√çVEIS!\n\nSua pontua√ß√£o final: ${gameState.score}\nEstilo m√°ximo alcan√ßado: ${gameState.styleRank}\nTotal de inimigos eliminados: ${gameState.killCount}`);
                gameState.currentLevel = 1;
            }
            
            showLevelTransition();
        }

        window.addEventListener('load', initGame);
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            };
        }
    </script>
</body>
    </html>
